*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="thor_run.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS thor_run AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "thor_run.h"
	*<DefinedPropArrayMethod>
		*m: add1tool
		*m: addalltools
		*m: addforums
		*m: addmenuitems
		*m: addopenfolder
		*m: addopenfolders
		*m: addpopuphotkeys
		*m: addsourcefile
		*m: addsourcefiles
		*m: addtoolhotkeys
		*m: assignallhotkeys
		*m: assigndedicatedhotkey
		*m: assignhotkeys
		*m: assignmultiplehotkeys
		*m: assignsimplehotkeys
		*m: assignthordispatcher
		*m: assignthordispatcherclasses
		*m: assignthordispatcherhelp
		*m: clear		&& Clears the contents of a ComboBox or ListBox control.
		*m: clearhotkeys		&& Removes all the Thor-assigned hotkeys
		*m: createmacro
		*m: createtoolbar
		*m: createtoplevelbars
		*m: createtoplevelpads
		*m: erasefile
		*m: executepopup
		*m: gethotkeyscollection
		*m: getpublishedclasses
		*m: popupalltools
		*m: run		&& Occurs when an Active Document is ready to execute your application code.
		*m: runstartupprgs
		*m: updateoptionslist
		*p: cdebugmenuname
		*p: cdedicatedhotkey
		*p: cdedicatedhotkeyfkyvalue
		*p: cthorapp
		*p: cthorfolder
		*p: fullfilename
		*p: ndebugmenubar
		*p: othorengine
		*p: otoolscollection
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		cdebugmenuname = 
		cdedicatedhotkey = Alt-F12
		cdedicatedhotkeyfkyvalue = 
		cthorapp = 
		cthorfolder = 
		fullfilename = 
		Name = "thor_run"
		ndebugmenubar = 0
		othorengine = .NULL.
		otoolscollection = .NULL.
		_memberdata = <VFPData>
			<memberdata name="addmenuitems" display="AddMenuItems"/>
			<memberdata name="createtoplevelbars" display="CreateTopLevelBars"/>
			<memberdata name="createtoplevelpads" display="CreateTopLevelPads"/>
			<memberdata name="run" display="Run"/>
			<memberdata name="assigndedicatedhotkey" display="AssignDedicatedHotKey"/>
			<memberdata name="assignthordispatcher" display="AssignThorDispatcher"/>
			<memberdata name="createmacro" display="CreateMacro"/>
			<memberdata name="addtoolhotkeys" display="AddToolHotKeys"/>
			<memberdata name="addpopuphotkeys" display="AddPopUpHotKeys"/>
			<memberdata name="executepopup" display="ExecutePopup"/>
			<memberdata name="cthorapp" display="cThorApp"/>
			<memberdata name="othorengine" display="oThorEngine"/>
			<memberdata name="cthorfolder" display="cThorFolder"/>
			<memberdata name="addalltools" display="AddAllTools"/>
			<memberdata name="cdedicatedhotkey" display="cDedicatedHotKey"/>
			<memberdata name="cdedicatedhotkeyfkyvalue" display="cDedicatedHotKeyFkyValue"/>
			<memberdata name="add1tool" display="Add1Tool"/>
			<memberdata name="runstartupprgs" display="RunStartupPRGs"/>
			<memberdata name="gethotkeyscollection" display="GetHotKeysCollection"/>
			<memberdata name="clearhotkeys" display="ClearHotKeys"/>
			<memberdata name="getpublishedclasses" display="GetPublishedClasses"/>
			<memberdata name="popupalltools" display="PopupAllTools"/>
			<memberdata name="createtoolonkeylabels" display="CreateToolOnKeyLabels"/>
			<memberdata name="assignsimplehotkeys" display="AssignSimpleHotKeys"/>
			<memberdata name="assignmultiplehotkeys" display="AssignMultipleHotKeys"/>
			<memberdata name="assignhotkeys" display="AssignHotKeys"/>
			<memberdata name="fullfilename" display="FullFileName"/>
			<memberdata name="addopenfolders" display="AddOpenFolders"/>
			<memberdata name="addopenfolder" display="AddOpenFolder"/>
			<memberdata name="addsourcefiles" display="AddSourceFiles"/>
			<memberdata name="addsourcefile" display="AddSourceFile"/>
			<memberdata name="cdebugmenuname" display="cDebugMenuName"/>
			<memberdata name="ndebugmenubar" display="nDebugMenuBar"/>
			<memberdata name="assignthordispatcherhelp" display="AssignThorDispatcherHelp"/>
			<memberdata name="assignthordispatcherclasses" display="AssignThorDispatcherClasses"/>
			<memberdata name="otoolscollection" display="oToolsCollection"/>
			<memberdata name="updateoptionslist" display="UpdateOptionsList"/>
			<memberdata name="addforums" display="AddForums"/>
			<memberdata name="createtoolbar" display="CreateToolBar"/>
			<memberdata name="assignallhotkeys" display="AssignAllHotKeys"/>
			<memberdata name="erasefile" display="EraseFile"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE add1tool
		Lparameters loContextMenu, loTool, tcFolder, tcActionPrefix
		Local laFavorite[1], lcKeyStroke, lcPRGName, lcPrompt, lcStatusBar
		
		lcPrompt	= m.loTool.Prompt
		lcPRGName	= Evl(m.tcActionPrefix, '') + Alltrim (m.loTool.PRGName)
		lcStatusBar	= Chrtran (Left (Alltrim (Evl(m.loTool.StatusBarText, m.loTool.Description)), 250), ccCRLF + ccTab, '   ')
		
		If Empty(m.tcActionPrefix)																	;
				And Indexseek (Upper (m.lcPRGName), .T., 'ToolHotKeyAssignments', 'PrgName')		;
				And ToolHotKeyAssignments.HotKeyID # 0
			Indexseek (ToolHotKeyAssignments.HotKeyID, .T., 'HotKeyDefinitions', 'ID')
			lcKeyStroke = Alltrim (HotKeyDefinitions.Descript)
		Else
			lcKeyStroke = ''
		Endif
		
		Select StartUp From Favorites Where Lower(PRGName) = Lower(m.lcPRGName) Into Array laFavorite
		m.loContextMenu.AddMenuItem (m.lcPrompt, [ExecScript(_Screen.cThorDispatcher, 'Thor_Proc_ProcessContextMenuItem', '] + m.lcPRGName + [')], m.lcStatusBar, m.lcKeyStroke, , m.lcPRGName, , Iif(m.laFavorite, 'B', ''))
	ENDPROC

	PROCEDURE addalltools
		*==============================================================================
		* Method:			AddAllTools
		* Purpose:			For the internal sub-menu 'All Tools', adds ALL tools
		* Author:			Jim Nelson
		* Last revision:	04/14/2011
		* Parameters:		loContextMenu, tcFolder
		* Returns:			none
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		Lparameters loContextMenu, tcFolder, lcOnlySource, tcActionPrefix
		
		Local laPrev[1], laThis[1], laTools[1], lcCategory, lcPrev, lcPreviousCategory, lcSource
		Local lcSubCategory, lcThis, lnI, lnJ, lnK, lnMax1, lnMax2, lnSort, lnStart, lnToolCount, loTool
		Local loTools
		
		loTools = This.oToolsCollection
		
		lnToolCount = loTools.Count
		If lnToolCount = 0
			Return
		Endif
		
		Dimension laTools (lnToolCount, 5)
		For lnI = 1 To lnToolCount
			loTool	 = loTools.Item (lnI)
			lcSource = Evl (Trim (loTool.Source), '(No Source)')
			*!* * Removed 2/3/2012
			*!* lcCategory	  = Trim (loTool.Category)
			lcCategory	  = Evl (Trim (loTool.Category), lcSource)
			lcSubCategory = Trim (loTool.SubCategory)
			lnSort		  = Evl(loTool.Sort, 9999)
		
			laTools (lnI, 1) = lnI
			laTools (lnI, 2) = lcSource
			laTools (lnI, 3) = lcCategory
			laTools (lnI, 4) = lcSubCategory
			* note the odd construction with lnSort! aha!
			laTools (lnI, 5) = loTool.InternalSort
		Endfor
		
		Asort (laTools, 5)
		lcPreviousCategory = ''
		
		For lnI = 1 To lnToolCount
		
			loTool	   = loTools.Item (laTools (lnI, 1))
			lcSource   = laTools (lnI, 2)
			lcCategory = laTools (lnI, 3)
		
			If lcSource == 'Thor'
				Loop
			Endif
		
			If Not lcCategory == lcPreviousCategory
				lnMax1 = Alines (laPrev, lcPreviousCategory, 5, '|')
				lnMax2 = Alines (laThis, lcCategory, 5, '|')
				If lnI = 1
					lnJ = 1
				Else
					lnStart = 1 + Min (lnMax1, lnMax2)
					For lnJ = 1 To Min (lnMax1, lnMax2)
						lcPrev = laPrev[lnJ]
						lcThis = laThis[lnJ]
						If Not Upper (lcPrev) == Upper (lcThis)
							lnStart = lnJ
							Exit
						Endif
					Endfor
					For lnK = lnStart To lnMax1
						loContextMenu.EndSubMenu ()
					Endfor
				Endif
				For lnK = lnJ To lnMax2
					loContextMenu.AddSubMenu (laThis[lnK])
				Endfor
			Endif
		
			This.Add1Tool (loContextMenu, loTool, tcFolder, tcActionPrefix)
			lcPreviousCategory = lcCategory
		
		Endfor && lnI = 1 To lnToolCount
		
		For lnI = 1 To (1 + Occurs ('|', lcPreviousCategory))
			loContextMenu.EndSubMenu ()
		Endfor
		
		Return
		
		
	ENDPROC

	PROCEDURE addforums
		Lparameters loContextMenu, lcNameProperty, lcLinkProperty
		
		Local laLinks[1], laNames[1], lcName, lnI, loTool, loTools
		loTools = This.oToolsCollection
		
		Create Cursor crsr_Forums (Name C(40), Link C(250))
		Index On Name Tag Name
		
		For Each loTool In loTools FoxObject
			If Not Empty (loTool.&lcNameProperty)
				Alines(laNames, loTool.&lcNameProperty)
				Alines(laLinks, loTool.&lcLinkProperty)
				For lnI = 1 To Min(Alen(laNames), Alen(laLinks))
					Locate For Upper(Trim(Name)) == Upper(Trim(laNames[lnI]))
					If Not Found()
						Insert Into crsr_Forums Values (laNames[lnI], laLinks[lnI])
					Endif
				Endfor
			Endif
		Endfor && each loTool in loTools foxobject
		
		Scan
			lcName = Alltrim(Chrtran(Name, [-], '')) && - insures that Thor's items appear at the top of the list
			loContextMenu.AddMenuItem (lcName, [ExecScript(_Screen.cThorDispatcher, 'Thor_Proc_Shell', '] + Trim (Link) + [')])
		Endscan
		
		
	ENDPROC

	PROCEDURE addmenuitems
		*==============================================================================
		* Method:			AddMenuItems
		* Purpose:			Adds bars (tools, separators, and sub-menus) to an existing menu
		*                   Recursive for handling sub-menus
		* Author:			Jim Nelson
		* Last revision:	03/21/2011
		* Parameters:		loContextMenu -- object for handling menus
		*					lnMenuID	  -- MenuID being processed for the current menu / sub-menu
		* 					tcFolder      -- folder for tools
		* Returns:			none
		* Environment in:	Table MenuDefinitions
		* Environment out:	none
		*==============================================================================
		
		Lparameters loContextMenu, lnMenuID, tcFolder, tcActionPrefix
		
		Local laMenuTools[1], lcKeyStroke, lcMenuStatusBar, lcPRGName, lcPrompt, lcStatusBar, llFavorite
		Local llSeparator, lnI, lnSubMenuID
		
		Select  MenuTools.Prompt,															;
				Separator,																	;
				SubMenuID,																	;
				MenuTools.PRGName,															;
				MenuTools.StatusBar,														;
				Cast (Nvl (MenuDefinitions.StatusBar, '') As M)    As  MenuStatusBar,		;
				Nvl(Favorites.StartUp, .F.)                        As  Favorite				;
			From MenuTools																	;
				Left Join MenuDefinitions													;
					On SubMenuID = MenuDefinitions.Id										;
				Left Join Favorites															;
					On Lower(MenuTools.PRGName) = Lower(Favorites.PRGName)					;
			Where MenuID = m.lnMenuID														;
			Order By MenuTools.SortOrder													;
			Into Array laMenuTools
		
		For lnI = 1 To _Tally
			lcPrompt		= Alltrim (m.laMenuTools (m.lnI, 1))
			llSeparator		= m.laMenuTools (m.lnI, 2)
			lnSubMenuID		= m.laMenuTools (m.lnI, 3)
			lcPRGName		= Evl (m.tcActionPrefix, '') + Alltrim (m.laMenuTools (m.lnI, 4))
			lcStatusBar		= Strtran (Left (Alltrim (m.laMenuTools (m.lnI, 5)), 250), ccCRLF, ' ')
			lcMenuStatusBar	= Strtran (Left (Alltrim (m.laMenuTools (m.lnI, 6)), 250), ccCRLF, ' ')
			llFavorite		= m.laMenuTools (m.lnI, 7)
		
			Do Case
				Case m.llSeparator
					m.loContextMenu.AddMenuItem ()
				Case m.lnSubMenuID # 0
					If Empty (m.tcActionPrefix)													;
							And Indexseek (m.lnSubMenuID, .T., 'MenuDefinitions', 'ID')			;
							And MenuDefinitions.HotKeyID # 0
						Indexseek (MenuDefinitions.HotKeyID, .T., 'HotKeyDefinitions', 'ID')
						lcKeyStroke = Alltrim (HotKeyDefinitions.Descript)
					Else
						lcKeyStroke = ''
					Endif
		
					m.loContextMenu.AddSubMenu (m.lcPrompt, m.lcMenuStatusBar, m.lcKeyStroke)
					This.AddMenuItems (m.loContextMenu, m.lnSubMenuID, m.tcFolder, m.tcActionPrefix)
					m.loContextMenu.EndSubMenu ()
				Case Upper (m.lcPRGName) = Upper (ccINTERNALEDITPRG)
					m.loContextMenu.AddMenuItem (m.lcPrompt, [ExecScript(_Screen.cThorDispatcher, '] + m.lcPRGName + [')], m.lcStatusBar,  This.oThorEngine.GetOption ('ThorHotKey'))
				Case Upper (m.lcPRGName) = Upper (ccINTERNALALLTOOLSPRG)
					m.loContextMenu.AddSubMenu (m.lcPrompt, m.lcMenuStatusBar)
					This.AddAllTools (m.loContextMenu, m.tcFolder, , ) &&ccModify)
					m.loContextMenu.EndSubMenu ()
				Case Upper (m.lcPRGName) = Upper (ccINTERNALMODIFY)
					m.loContextMenu.AddSubMenu (m.lcPrompt, m.lcMenuStatusBar)
					This.AddAllTools (m.loContextMenu, m.tcFolder, , ccModify)
					m.loContextMenu.EndSubMenu ()
				Case Upper (m.lcPRGName) = Upper (ccOPENFOLDERS)
					m.loContextMenu.AddSubMenu (m.lcPrompt, m.lcMenuStatusBar)
					This.AddOpenFolders (m.loContextMenu)
					m.loContextMenu.EndSubMenu ()
				Case Upper (m.lcPRGName) = Upper (ccSOURCEFILES)
					m.loContextMenu.AddSubMenu (m.lcPrompt, m.lcMenuStatusBar)
					This.AddSourceFiles (m.loContextMenu)
					m.loContextMenu.EndSubMenu ()
				Case Upper (m.lcPRGName) = Upper (ccINTERNALTOOLLINK)
					m.loContextMenu.AddSubMenu (m.lcPrompt, m.lcMenuStatusBar)
					This.AddAllTools (m.loContextMenu, m.tcFolder, , ccLink)
					m.loContextMenu.EndSubMenu ()
		
				Case Upper (m.lcPRGName) = Upper ('Thor-Forums')
					m.loContextMenu.AddMenuItem ('Project Home Pages', [ExecScript(_Screen.cThorDispatcher, 'Thor_Tool_ProjectHomePages')])
		
				Case Upper (m.lcPRGName) = Upper ('Thor-Blogs')
					m.loContextMenu.AddSubMenu ('Blogs', '')
					This.AddForums(m.loContextMenu, 'BlogName', 'BlogLink')
					m.loContextMenu.EndSubMenu ()
		
				Case Upper (m.lcPRGName) = Upper ('Thor-ChangeLogs')
					m.loContextMenu.AddSubMenu ('Change Logs', '')
					This.AddForums(m.loContextMenu, 'ChangeLogName', 'ChangeLogLink')
					m.loContextMenu.EndSubMenu ()
		
				Case Upper (m.lcPRGName) = Upper ('Thor-ERs')
					m.loContextMenu.AddMenuItem ('Thor ERs', [ExecScript(_Screen.cThorDispatcher, 'Thor_Proc_Shell', 'https://docs.google.com/document/d/1TPFfbNKLhcqT_EzPVYw5jdikSoRn12hvAIq4M10beIQ/edit')])
		
				Case Upper (m.lcPRGName) = Upper ('Thor-Videos')
					*** DH 2018-04-10: new URL
					m.loContextMenu.AddMenuItem ('\<Videos', [ExecScript(_Screen.cThorDispatcher, 'Thor_Proc_Shell', 'https://github.com/VFPX/Thor/blob/master/Docs/Thor_videos.md')])
		
				Case Upper (m.lcPRGName) = Upper (ccDEBUGMODE)
					m.loContextMenu.AddMenuItem (m.lcPrompt, [ExecScript(_Screen.cThorDispatcher, '] + ccTOGGLEDEBUGMODE + [')], m.lcStatusBar, Nvl(m.lcKeyStroke, ''))
					This.cDebugMenuName	= m.loContextMenu.cMenuName
					This.nDebugMenuBar	= m.loContextMenu.nMenuBar
				Otherwise
					If Indexseek (Upper (m.lcPRGName), .T., 'ToolHotKeyAssignments', 'PrgName') And ToolHotKeyAssignments.HotKeyID # 0
						Indexseek (ToolHotKeyAssignments.HotKeyID, .T., 'HotKeyDefinitions', 'ID')
						lcKeyStroke = Alltrim (HotKeyDefinitions.Descript)
					Else
						lcKeyStroke = ''
					Endif
		
					m.loContextMenu.AddMenuItem (m.lcPrompt, [ExecScript(_Screen.cThorDispatcher, 'Thor_Proc_ProcessContextMenuItem', '] + m.lcPRGName + [')], m.lcStatusBar, m.lcKeyStroke, , m.lcPRGName, , Iif(m.llFavorite, 'B', ''))
			Endcase
		Endfor
		
		
	ENDPROC

	PROCEDURE addopenfolder
		Lparameters loContextMenu, lcCaption, lcFolder
		
		If Directory(lcFolder)
			loContextMenu.AddMenuItem (lcCaption, [ExecScript(_Screen.cThorDispatcher, 'Thor_Proc_OpenFolder', '] + lcFolder + [')]) 
		EndIf 
		
	ENDPROC

	PROCEDURE addopenfolders
		Lparameters loContextMenu
		
		Local lcFolder, lcToolFolder, loTool
		lcToolFolder = Addbs (Execscript (_Screen.cThorDispatcher, 'Tool Folder='))
		
		This.AddOpenFolder (loContextMenu, 'My Tools', lcToolFolder + 'My Tools')
		This.AddOpenFolder (loContextMenu, 'Apps', lcToolFolder + 'Apps' )
		This.AddOpenFolder (loContextMenu, 'Components', lcToolFolder + 'Components' )
		
		loContextMenu.AddMenuItem ()
		
		This.AddOpenFolder (loContextMenu, 'Tools', lcToolFolder )
		This.AddOpenFolder (loContextMenu, 'Procs', lcToolFolder + 'Procs')
		This.AddOpenFolder (loContextMenu, 'Tables', lcToolFolder + '..\Tables')
		
		loContextMenu.AddMenuItem ()
		
		m.loContextMenu.AddMenuItem ('CFU logs', [ExecScript(_Screen.cThorDispatcher, 'Thor_Tool_ThorCFULog')])
	ENDPROC

	PROCEDURE addpopuphotkeys
		*==============================================================================
		* Method:			AddPopUpHotKeys
		* Purpose:			Adds all of the hot key definitions for pop-ups to the collection
		* Author:			Jim Nelson
		* Last revision:	03/22/2011
		* Parameters:		loCollection	-- one item per hot key 
		* Returns:			none
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		Lparameters loCollection
		
		Local loMacro As 'Empty'
		Local laHotKeys[1], lcDescript, lcFKYValue, lcMacro, lcPRGName, lnI
		Select  Descript, FKYValue, MenuDefinitions.Id, nshifts, Descript  ;
			From MenuDefinitions										   ;
				Join HotKeyDefinitions									   ;
					On MenuDefinitions.hotkeyid = HotKeyDefinitions.Id	   ;
					And FKYValue # ' '									   ;
			Into Array laHotKeys
		
		For lnI = 1 To _Tally
			lcDescript = Trim (laHotKeys (lnI, 1))
			lcFKYValue = laHotKeys (lnI, 2)
			lcPRGName  = ccPOPUPID + Transform (laHotKeys (lnI, 3))
		
			lcMacro	= This.CreateMacro ('Thor:' + lcDescript, lcFKYValue, This.cDedicatedHotKeyFkyValue, lcPRGName + Chr(13))
			loMacro	= Createobject ('Empty')
			AddProperty (loMacro, 'Text', lcMacro)
			AddProperty (loMacro, 'NShifts', laHotKeys (lnI, 4))
			AddProperty (loMacro, 'Descript', laHotKeys (lnI, 5))
			AddProperty (loMacro, 'Execute', lcPRGName)
		
			loCollection.Add (loMacro)
		Endfor
		
	ENDPROC

	PROCEDURE addsourcefile
		Lparameters loContextMenu, lcSourceFileURL
		
		Local laLines[1]
		If Alines (laLines, lcSourceFileURL, 1, '=') > 1
			loContextMenu.AddMenuItem (laLines(1), [ExecScript(_Screen.cThorDispatcher, 'Thor_Proc_Shell', '] + Trim (laLines[2]) + [')]) 
		EndIf 
		
	ENDPROC

	PROCEDURE addsourcefiles
		Lparameters loContextMenu
		
		Local lcSourceFileURL, lnI, loOtherUpdaters, loThorUpdater
		
		loThorUpdater	= Execscript (_Screen.cThorDispatcher, 'Thor_Proc_GetUpdateList', .T.)
		For lnI = 1 To loThorUpdater.Count
			lcSourceFileURL = loThorUpdater (lnI).SourceFileURL
			If Not Empty (lcSourceFileURL)
				This.AddSourceFile (loContextMenu, lcSourceFileURL)
			Endif
		Endfor
		
		loOtherUpdaters = Execscript (_Screen.cThorDispatcher, 'Thor_Proc_GetUpdateList', .F.)
		For lnI = 1 To loOtherUpdaters.Count
			lcSourceFileURL = loOtherUpdaters (lnI).SourceFileURL
			If Not Empty (lcSourceFileURL)
				This.AddSourceFile (loContextMenu, lcSourceFileURL)
			Endif
		Endfor
		
		
		
	ENDPROC

	PROCEDURE addtoolhotkeys
		*==============================================================================
		* Method:			AddToolHotKeys
		* Purpose:			Adds all of the hot key definitions for tools to the collection
		* Author:			Jim Nelson
		* Last revision:	03/22/2011
		* Parameters:		tcFolder    	-- main Thor folder
		*					loCollection	-- one item per hot key 
		* Returns:			none
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		Lparameters tcFolder, loCollection
		
		Local loMacro As 'Empty'
		Local laHotKeys[1], lcDescript, lcFKYValue, lcMacro, lcPRGName, lnI
		Select  Descript, fkyvalue, prgname, nshifts, Descript				  ;
			From ToolHotKeyAssignments										  ;
				Join HotKeyDefinitions										  ;
					On ToolHotKeyAssignments.hotkeyid = HotKeyDefinitions.Id  ;
					And fkyvalue # ' '										  ;
			Into Array laHotKeys
		
		For lnI = 1 To _Tally
			lcDescript = Trim (laHotKeys (lnI, 1))
			lcFKYValue = laHotKeys (lnI, 2)
			lcPRGName  = Trim (laHotKeys (lnI, 3))
		
			lcMacro	= This.CreateMacro ('Thor:' + lcDescript, lcFKYValue, This.cDedicatedHotKeyFkyValue, lcPRGName + Chr(13))
			loMacro	= Createobject ('Empty')
			AddProperty (loMacro, 'Text', lcMacro)
			AddProperty (loMacro, 'NShifts', laHotKeys (lnI, 4))
			AddProperty (loMacro, 'Descript', laHotKeys (lnI, 5))
			AddProperty (loMacro, 'Execute', lcPRGName)
		
			loCollection.Add (loMacro)
		Endfor
		
	ENDPROC

	PROCEDURE assignallhotkeys
		Local loKeysCollection
		
		With This
		
		    .AssignDedicatedHotKey()
		    
		   	.ClearHotKeys()
		
		    loKeysCollection = .GetHotKeysCollection(.cThorFolder + 'Tools\')
		
		    .AssignSimpleHotKeys (loKeysCollection)
		
		    .AssignMultipleHotKeys (loKeysCollection)
		
		Endwith
	ENDPROC

	PROCEDURE assigndedicatedhotkey
		*==============================================================================
		* Method:			AssignDedicatedHotKey
		* Purpose:			Assigns the On Key Label hotkey dedicated for use by Thor for executing macros
		* Author:			Jim Nelson
		* Last revision:	04/14/2011
		* Parameters:		none
		* Returns:			none
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		Local lcHotKey
		
		lcHotKey = Evl(This.oThorEngine.GetOption ('ThorHotKey'), This.cDedicatedHotKey)
		Try
			On Key Label &lcHotKey Execscript (_Screen.cThorDispatcher)
			This.cDedicatedHotKey = lcHotKey
		Catch
			lcHotKey = This.cDedicatedHotKey
			On Key Label &lcHotKey Execscript (_Screen.cThorDispatcher)
		Endtry
		
		This.cDedicatedHotKeyFkyValue = This.oThorEngine.GetKeyValueFromKeyName (lcHotKey)
		
	ENDPROC

	PROCEDURE assignhotkeys
		*==============================================================================
		* Method:			AssignHotKeys
		* Purpose:			Assigns both kinds of hot keys, using RESTORE MACROS
		* Author:			Jim Nelson
		* Last revision:	03/21/2011
		* Parameters:		tcFolder ... main Thor folder
		* Returns:			none
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		Lparameters loHotKeysCollection
		
		Local lcFKYFile, lcMacros, lnCount, lnI
		
		lnCount = loHotKeysCollection.Count
		If lnCount = 0
			Return
		Endif
		
		lcMacros = Chr(0xFF) + Chr(0x79) +		;
			Replicate (Chr(32), 13) + Chr(0) +	;
			Chr (lnCount % 256) + Chr (Int (lnCount / 256))
		For lnI = 1 To lnCount
			lcMacros = lcMacros + loHotKeysCollection.Item (lnI)
		Endfor
		
		lcFKYFile = Addbs (Sys(2023)) + Forceext (Sys(2015), 'FKY')
		This.EraseFile(lcFKYFile)
		
		Strtofile (lcMacros, lcFKYFile)
		Restore Macros From (lcFKYFile)
		
		This.EraseFile(lcFKYFile)
		
	ENDPROC

	PROCEDURE assignmultiplehotkeys
		*==============================================================================
		* Method:			AssignMultipleKeys
		* Purpose:			Assigns both kinds of hot keys, using RESTORE MACROS
		* Author:			Jim Nelson
		* Last revision:	03/21/2011
		* Parameters:		tcFolder ... main Thor folder
		* Returns:			none
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		Lparameters loHotKeysCollection
		
		Local lcFKYFile, lcMacros, lnCount, lnI, lnTotalMacros, loMacro
		
		lnCount = loHotKeysCollection.Count
		If lnCount = 0
			Return
		Endif
		
		lcMacros	  = ''
		lnTotalMacros = 0
		For lnI = 1 To lnCount
			loMacro = loHotKeysCollection.Item (lnI)
			If (Inlist (loMacro.nShifts, 3, 5, 6, 7) or (loMacro.nShifts = 0 and InList(loMacro.Descript, 'F6', 'F7', 'F8')))
				lcMacros	  = lcMacros + loMacro.Text
				lnTotalMacros = lnTotalMacros + 1
			Endif
		Endfor
		
		lcMacros = Chr(0xFF) + Chr(0x79) +							 ;
			Replicate (Chr(32), 13) + Chr(0) +						 ;
			Chr (lnTotalMacros % 256) + Chr (Int (lnCount / 256)) +	 ;
			lcMacros
		
		lcFKYFile = Addbs (Sys(2023)) + Forceext (Sys(2015), 'FKY')
		This.EraseFile(lcFKYFile)
		
		Strtofile (lcMacros, lcFKYFile)
		Restore Macros From (lcFKYFile)
		
		This.EraseFile(lcFKYFile)
		
	ENDPROC

	PROCEDURE assignsimplehotkeys
		*==============================================================================
		* Method:			AssignMultipleKeys
		* Purpose:			Assigns both kinds of hot keys, using RESTORE MACROS
		* Author:			Jim Nelson
		* Last revision:	03/21/2011
		* Parameters:		tcFolder ... main Thor folder
		* Returns:			none
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		Lparameters loHotKeysCollection
		
		Local loMacro, lcExecute, lcKey, lcOnKeyLabel, lnI
		
		For lnI = 1 To loHotKeysCollection.Count
			loMacro = loHotKeysCollection.Item (lnI)
			If not (Inlist (loMacro.nShifts, 3, 5, 6, 7) or (loMacro.nShifts = 0 and InList(loMacro.Descript, 'F6', 'F7', 'F8')))
				lcKey = loMacro.Descript
				lcExecute = loMacro.Execute
				lcOnKeyLabel = ccOnKeyLabelPrefix + lcExecute + ccOnKeyLabelSuffix
				On Key Label &lcKey &lcOnKeyLabel
			Endif
		Endfor
		
	ENDPROC

	PROCEDURE assignthordispatcher
		*==============================================================================
		* Method:			AssignThorDispatcher
		* Purpose:			Creates the actual dispatcher which reads the keyboard buffer to ascertain
		*                   the name of the tool selected, and calls the PRG.
		*                   The executable code is stored in _Screen.cThorExecute
		* Author:			Jim Nelson
		* Last revision:	04/14/2011
		* Parameters:		none
		* Returns:			none
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		Lparameters tcThorApp, tcFolder
		
		Local lcHomeDir, lcPublishedClasses, lcPublishedClassesHelp, lcThorExecute, lcHomeFolder
		
		lcPublishedClasses	   = This.GetPublishedClasses()
		lcPublishedClassesHelp = Evl (This.GetPublishedClasses (.T.), '[]')
		lcHomeFolder		   = Addbs(JustPath(tcThorApp))
		
		*** DH 2018-10-12: as suggested by Toni Koehler, use ALLTRIM(STR()) instead of
		*** TRANSFORM() because with SET POINT TO ',' and SET FIXED ON, TRANSFORM(1)
		*** gives "1,000" which looks like multiple parameters: lcP1,lxP2,000,lxP3,000, etc.
		*			lcParams = lcParams + ', lxP' + Transform(lnI)
		** TP 2019-02-28: reducing the size of the code stored in cThorDispatcher
		** moved the above comment out of the TEXT...ENDTEXT area
		** Add the PRETEXT 1+2+4 to the TEXT...ENDTEXT to reduce the size of the output
		* Text To lcThorExecute Noshow TEXTMERGE
		****************************************************************
		Text To lcThorExecute TEXTMERGE NOSHOW PRETEXT 1+2+4 
		LParameters lcPRGName, lxP1, lxP2, lxP3, lxP4, lxP5, lxP6, lxP7, lxP8, lxP9, lxP10
		
		Local loGetThor As 'GetThorRun'
		Local lcFile, lcFolder, lcSys16, lcThorApp, lcThorFolder, llFirst, llThorInkey, lnI, lnInkey, lnPopUpID
		Local lnWindowOnTop, loLink, loPEME_Tools, loResult, loThorEngine, loThorInfo, loThorRun
		
		lcFolder	 = '<<lcHomeFolder>>'
		lcThorApp	 = lcFolder + '<<JustFname(tcThorApp)>>'
		lcThorFolder = lcFolder + '<<Substr(tcFolder, 1 + Len(lcHomeFolder))>>' 
		_Screen.AddProperty('cThorFolder', lcThorFolder)
		
		llThorInkey = .F.
		If Empty (lcPRGName)
			llThorInkey	= .T.
			lcPRGName	= ''
			Do While Chrsaw()
				lnInkey		= Inkey()
				If lnInkey = 13
					Exit
				Endif
				lcPRGName = lcPRGName + Chr (lnInkey)
			EndDo
		Endif
		
		Do Case
			Case Atc('Thor_', lcPrgName) = 1 
				Return ExecuteThorProc(lcPRGName, lcThorFolder, llThorInkey, .F., Pcount(), @lxP1, @lxP2, @lxP3, @lxP4, @lxP5, @lxP6, @lxP7, @lxP8, @lxP9, @lxP10)
		
			Case Atc([<<ccFullPath>>], lcPrgName) = 1
				lcFile         = GetFullFileName (Alltrim (Substr (lcPRGName, At ('=', lcPRGName) + 1)), lcThorFolder)
				Return lcFile
		
			Case Atc([<<ccClass>>], lcPrgName) = 1
				Return ExecScript(_Screen.cThorDispatcherClasses, lcPRGName, lcThorAPP, Pcount(), lxP1, lxP2, lxP3, lxP4, lxP5)
		
			Case Atc([<<ccPOPUPID>>], lcPrgName) = 1
				loGetThor = Createobject ('GetThorRun')
				loThorRun = loGetThor.GetThorRun (lcThorApp, lcThorFolder)
				lnPopUpID = Val (Substr (lcPRGName, 1 + At ('=', lcPRGName)))
				loThorRun.ExecutePopup (lnPopUpID, lcThorFolder, Set ('DataSession'))
		
			Case Atc([<<ccResult>>], lcPrgName) = 1
				_Screen.xThorResult	= lxP1
				Return lxP1
		
			Case Empty (lcPRGName)
				Do (lcThorApp) With 'Edit'
		
			Case Atc([FORMRUNTOOL], lcPrgName) = 1
				Do (lcThorApp) With 'FORMRUNTOOL'
		
			Case Atc([?], lcPrgName) = 1
				Return ExecScript(_Screen.cThorDispatcherHelp)
		
			Case Atc([<<ccRun>>], lcPrgName) = 1
				loGetThor = Createobject ('GetThorRun')
				loThorRun = loGetThor.GetThorRun (lcThorApp, lcThorFolder)
				loThorRun.Run()
		
			Case Atc([<<ccTOOLFOLDER>>], lcPrgName) = 1
				Return lcThorFolder + 'Tools\'
		
			Case Atc([<<ccGETVERSION>>], lcPrgName) = 1
				Return ccThorVersion
		
			Case Atc([<<ccTHORENGINE>>], lcPrgName) = 1
				loThorEngine = FetchThorEngine(lcThorApp, lcThorFolder)
				Return loThorEngine
		
			Case Atc([<<ccTHORREGISTER>>], lcPrgName) = 1
				loGetThor  = Createobject ('Getthorinfo')
				loThorInfo = loGetThor.Getthorinfo (lcThorApp)
				Return loThorInfo
		
			Case Atc([Get Option=], lcPrgName) = 1
				loThorEngine = FetchThorEngine(lcThorApp, lcThorFolder)
				Return loThorEngine.GetOption(lxP1, lxP2)
		
			Case Atc([Set Option=], lcPrgName) = 1
				loThorEngine = FetchThorEngine(lcThorApp, lcThorFolder)
				Return loThorEngine.SetOption(lxP1, lxP2, lxP3)
		
			Case Atc([<<ccTOOLTEMPLATE>>], lcPrgName) = 1
				loGetThor  = Createobject ('Getthorinfo')
				loThorInfo = loGetThor.Getthorinfo (lcThorApp)
				Return loThorInfo.GetSampleToolCode()
		
			Case Atc([<<ccThorClearHotKeys>>], lcPrgName) = 1
				Do (lcThorApp) With 'Clear HotKeys'
		
			Case Atc([<<ccToggleDebugMode>>], lcPrgName) = 1
				_Screen.lThorDebugMode = not _Screen.lThorDebugMode		
				Set Mark of Bar <<This.nDebugMenuBar>> of <<This.cDebugMenuName>> to _Screen.lThorDebugMode
				If _Screen.lThorDebugMode
					Set Asserts on
				EndIf 
		
			Case Atc([<<ccModify>>], lcPrgName) = 1
				lcFile         = GetFullFileName (Alltrim (Substr (lcPRGName, At ('=', lcPRGName) + 1)), lcThorFolder)
				If Empty (lcFile)
					Return .Null.
				Endif
		
				Return ExecuteThorProc('Thor_Proc_EditProc', lcThorFolder, llThorInkey, .F., 2, lcFile)
		
			Case Atc([<<ccLink>>], lcPrgName) = 1
				lcFile         = GetFullFileName (Alltrim (Substr (lcPRGName, At ('=', lcPRGName) + 1)), lcThorFolder)
				If Empty (lcFile)
					Return .Null.
				Endif
		
				loThorInfo = Newobject ('ThorInfo', 'Thor_Utils.vcx', lcThorApp)
				Do (lcFile) With loThorInfo
				loThorInfo.PrgName		= Justfname (lcFile)
				loThorInfo.FullFileName	= lcFile
				If Empty (loThorInfo.Link)
					loThorEngine = FetchThorEngine(lcThorApp, lcThorFolder)
					Messagebox (loThorEngine.GetToolDescription (loThorInfo))
				Else
					loLink = Newobject ('_ShellExecute', Home() + 'FFC\_Environ.vcx')
					loLink.ShellExecute (loThorInfo.Link)
				Endif
		
				* Get ToolInfo for tool
			Case Atc([<<ccToolInfo>>], lcPrgName) = 1
				loResult = .Null.
				If Empty (lxP1) Or 'C' # Vartype (lxP1)
					Return loResult
				Endif
		
				lcFile         = GetFullFileName (lxP1, lcThorFolder)
				If Empty (lcFile)
					Return loResult
				Endif
		
				Try
					loThorInfo = Newobject ('ThorInfo', 'Thor_Utils.vcx', lcThorApp)
					Do (lcFile) With loThorInfo
					loThorInfo.PrgName		= Justfname (lcFile)
					loThorInfo.FullFileName	= lcFile
					loResult				= loThorInfo
				Catch
		
				Endtry
				Return loResult
		
			Case Atc([<<ccDoDefault>>], lcPrgName) = 1
				lcPRGName = ''
				llFirst	  = .F.
				For lnI = Program (-1) To 1 Step - 1
					lcSys16 = Sys(16, lnI)
					Do Case
						Case Upper (Getwordnum (lcSys16, 1)) = 'PROCEDURE'
						Case Not llFirst
							llFirst = .T.
						Otherwise
							lcPRGName = JustStem (lcSys16)
							Exit
					Endcase
				Endfor
		
				Return ExecuteThorProc (lcPRGName, lcThorFolder, llThorInkey, .T., Pcount(), @lxP1, @lxP2, @lxP3, @lxP4, @lxP5, @lxP6, @lxP7, @lxP8, @lxP9, @lxP10)
		
			Otherwise
				Return ExecuteThorProc(lcPRGName, lcThorFolder, llThorInkey, .F., Pcount(), @lxP1, @lxP2, @lxP3, @lxP4, @lxP5, @lxP6, @lxP7, @lxP8, @lxP9, @lxP10)
		
		Endcase
		
		Return
		
		
		Procedure ExecuteThorProc
			Lparameters lcPRGName, lcThorFolder, llThorInkey, llDoDefault, lnPCount, lxP1, lxP2, lxP3, lxP4, lxP5, lxP6, lxP7, lxP8, lxP9, lxP10, lcFileText
		
			Local lcFullPRGName, lcParams, lnI
			lcFullPRGName = GetFullFileName(lcPRGName, lcThorFolder, llDoDefault)
			If Empty(lcFullPRGName)
				Return .Null.
			Endif
		
			_Screen.lThorInkey	= _Screen.lThorInkey Or llThorInkey
			_Screen.xThorResult	= .T.
			If lnPCount < 2
				lcParams = ''
			Else
				lcParams = 'with lxP1'
				For lnI = 2 To lnPCount - 1
					lcParams = lcParams + ', lxP' + alltrim(str(lnI))
				Endfor
			Endif
		
			Assert Not _Screen.lThorDebugMode Message 'Debug:     ' + Juststem(lcFullPRGName)
			Do(lcFullPRGName) &lcParams
		
			_Screen.lThorInkey = _Screen.lThorInkey And Type('llThorInkey') = 'L' And Not llThorInkey
			Return _Screen.xThorResult
		Endproc
		
		
		Function GetFullFileName (lcPRGName, lcThorFolder, llDoDefault)
			Local lcFile, lcFullPRGName1, lcFullPRGName2
		
			If Empty(JustExt(lcPRGName)) 
				lcFile = Forceext (lcPRGName, 'prg')
			Else
				lcFile = lcPRGName
			EndIf 
			lcFullPRGName1 = Forcepath (lcFile, lcThorFolder + 'Tools\' + ccMyTools)
			lcFullPRGName2 = Forcepath (lcFile, lcThorFolder + 'Tools\' + ccProcs)
			lcFullPRGName3 = Forcepath (lcFile, lcThorFolder + 'Tools\')
			Do Case
				Case File (lcFile) and not llDoDefault
					lcFile = Fullpath (lcFile)
				Case File (lcFullPRGName1) and not llDoDefault
					lcFile = lcFullPRGName1
				Case File (lcFullPRGName2)
					lcFile = lcFullPRGName2
				Case File (lcFullPRGName3)
					lcFile = lcFullPRGName3
				Otherwise
					lcFile = ''
			Endcase
			Return lcFile
		EndFunc
		
		Function FetchThorEngine(lcThorApp, lcThorFolder)
			Local loGetThor As 'GetThorEngine'
			Local loThorEngine
			If PemStatus(_Screen, 'oThorEngine', 5) and Vartype(_Screen.oThorEngine) = 'O'
				loThorEngine = _Screen.oThorEngine
			Else
				loGetThor	 = Createobject('GetThorEngine')
				loThorEngine = loGetThor.GetThorEngine(lcThorApp, lcThorFolder)
				_Screen.AddProperty('oThorEngine', loThorEngine)
			EndIf 
			Return loThorEngine
		Endfunc
		
		Define Class GetThorRun As Session
		
		    Procedure GetThorRun (lcThorApp, lcThorFolder)
		    	Local loThorRun
		        loThorRun = Newobject ('Thor_Run', 'thor_run.vcx', lcThorApp, lcThorApp, lcThorFolder)
		        loThorRun.AddProperty('cApplication', lcThorApp)
		        Return loThorRun 
		    Endproc
		
		Enddefine
		
		Define Class GetThorEngine As Session
		
		    Procedure GetThorEngine (lcThorApp, lcThorFolder)
		        Return Newobject ('Thor_Engine', 'Thor.vcx', lcThorApp, lcThorFolder)
		    Endproc
		
		Enddefine
		
		Define Class GetThorInfo As Session
		
		    Procedure GetThorInfo (lcThorApp)
		        Return Newobject ('ThorInfo', 'Thor_Utils.vcx', lcThorApp)
		    Endproc
		
		Enddefine
		
		EndText
		
		lcThorExecute = Chrtran(lcThorExecute, ccLF, '')
		** TP 2019-02-28: with the changes above, this line is not needed
		** left the above line in to reduce the stored string a little more
		* lcThorExecute = Chrtran(lcThorExecute, ccCR + ccCR, ccCR)
		
		****************************************************************
		
		lcPropertyName = 'cThorDispatcher'
		Removeproperty (_Screen, lcPropertyName)
		
		_Screen.AddProperty (lcPropertyName, lcThorExecute)
		_Screen.AddProperty ('lThorInkey', .F.)
		_Screen.AddProperty ('xThorResult', .F.)
		_Screen.AddProperty ('lThorExecScript', .F.)
		_Screen.AddProperty ('lThorDebugMode', .F.)
		
		*!* * Removed 2/3/2013 / JRN
		*!* If 'C' # Type ('_Screen._MemberData')
		*!* 	_Screen.AddProperty ('_MemberData', ccThorMemberData)
		*!* Endif
		
		Return
		
		
	ENDPROC

	PROCEDURE assignthordispatcherclasses
		Lparameters tcThorApp, tcFolder
		
		Local lcHomeDir, lcPropertyName, lcPublishedClasses, lcPublishedClassesHelp, lcThorExecute
		
		lcPublishedClasses	   = This.GetPublishedClasses()
		
		Text To lcThorExecute Noshow Textmerge
		Lparameters lcPRGName, lcThorAPP, lnPCount, lxP1, lxP2, lxP3, lxP4, lxP5
		Local lcClass, lcClassLib, lcClassName, lcFileName, loEditorWin, loObject
		lcClassName = Alltrim (Substr (lcPRGName, 1 + Len (ccClass)))
		Do Case
			Case Lower (lcClassName) = 'contextmenu'
				Return Newobject ('contextmenu', 'thor_menu.vcx', lcThorAPP, , , lxP1)
			Case Lower (lcClassName) = 'settings'
				Return Newobject ('thor_resource', 'thor_foxresource.vcx', lcThorAPP)
			Case Lower (lcClassName) = 'thorformsettings'
				Return Newobject ('thor_form_settings', 'thor_foxresource.vcx', lcThorAPP, lxP1)
			Case Lower (lcClassName) = 'formruntool'
				Return Newobject ('formruntool', 'thor_ui.vcx', lcThorAPP, Addbs(JustPath(lcThorAPP)))
			Case Lower (lcClassName) = 'optionrenderengine'
				lcFileName = Execscript (_Screen.cThorDispatcher, 'Full Path=Thor_Proc_DynamicForm.prg')
				Return Newobject ('Thor_Proc_DynamicFormRenderEngine', lcFileName) 
			Case Lower (lcClassName) = 'dynamicformdesktop'
				lcFileName = Execscript (_Screen.cThorDispatcher, 'Full Path=Thor_Proc_DynamicForm.prg')
				Return Newobject ('Thor_DynamicFormDeskTop', lcFileName) 
			Case Lower (lcClassName) = 'dynamicform'
				lcFileName = Execscript (_Screen.cThorDispatcher, 'Full Path=Thor_Proc_DynamicForm.prg')
				Return Newobject ('Thor_DynamicForm', lcFileName) 
			Case Lower (lcClassName) = 'findexe'
				Return Newobject ('FindEXE', 'thor_utils.vcx', lcThorAPP)
		<< lcPublishedClasses >>
			Otherwise
				lcClass	   = Getwordnum (lcClassName, 1)
				lcClassLib = Getwordnum (lcClassName, Getwordcount (lcClassName))
				lcFileName = Execscript (_Screen.cThorDispatcher, 'Full Path=' + lcClassLib)
				Do Case
					Case lnPCount < 2
						loObject   = Newobject (lcClass, lcFileName)
					Case lnPCount = 2
						loObject   = Newobject (lcClass, lcFileName, '', lxP1)
					Case lnPCount = 3
						loObject   = Newobject (lcClass, lcFileName, '', lxP1, lxP2)
					Case lnPCount = 4
						loObject   = Newobject (lcClass, lcFileName, '', lxP1, lxP2, lxP3)
					Case lnPCount = 5
						loObject   = Newobject (lcClass, lcFileName, '', lxP1, lxP2, lxP3, lxP4)
					Case lnPCount = 6
						loObject   = Newobject (lcClass, lcFileName, '', lxP1, lxP2, lxP3, lxP4, lxP5)
					Otherwise
				Endcase
				Return loObject
		EndCase 
		Endtext
		
		****************************************************************
		lcPropertyName = 'cThorDispatcherClasses'
		Removeproperty (_Screen, lcPropertyName)
		
		_Screen.AddProperty (lcPropertyName, lcThorExecute)
		
	ENDPROC

	PROCEDURE assignthordispatcherhelp
		*==============================================================================
		* Method:			AssignThorDispatcher
		* Purpose:			Creates the actual dispatcher which reads the keyboard buffer to ascertain
		*                   the name of the tool selected, and calls the PRG.
		*                   The executable code is stored in _Screen.cThorExecute
		* Author:			Jim Nelson
		* Last revision:	04/14/2011
		* Parameters:		none
		* Returns:			none
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		Lparameters tcThorApp, tcFolder
		
		Local lcPropertyName, lcPublishedClassesHelp, lcThorExecute, lcFolder
		lcQuote = IIF(' ' $ tcFolder, ['], '')
		lcPublishedClassesHelp = Evl (This.GetPublishedClasses (.T.), '[]')
		
		****************************************************************
		
		Text To lcThorExecute Noshow Textmerge
		loResult = Createobject ('Empty')
		
		lxResult = ''
		lxResult = lxResult + ccCR + ccLF + [Empty]
		lxResult = lxResult + ccCR + ccLF + [* get an option]
		lxResult = lxResult + ccCR + ccLF + [lxValue      |] + [Get Option=] + [", cKey, cTool]
		lxResult = lxResult + ccCR + ccLF + [Empty]
		lxResult = lxResult + ccCR + ccLF + [* set an option]
		lxResult = lxResult + ccCR + ccLF + [Set Option=] + [", cKey, cTool, xValue]
		lxResult = lxResult + ccCR + ccLF + [Empty]
		lxResult = lxResult + ccCR + ccLF + [lcVersion    |] + [<<ccGETVERSION>>]
		lxResult = lxResult + ccCR + ccLF + [Empty]
		lxResult = lxResult + ccCR + ccLF + [lcToolFolder |] + [<<ccTOOLFOLDER>>]
		lxResult = lxResult + ccCR + ccLF + [Empty]
		lxResult = lxResult + ccCR + ccLF + [* Return full file name and path]
		lxResult = lxResult + ccCR + ccLF + [lcFileName   |] + [<<ccFullPath>>] + [" + ToolName) &] + [& e.g., "Thor_Tool_GoFish4]
		lxResult = lxResult + ccCR + ccLF + [Empty]
		*** DH 2018-04-10: new URL
		lxResult = lxResult + ccCR + ccLF + [* ContextMenu home page = https://github.com/VFPX/Thor/blob/master/Docs/Thor_framework_contextmenu.md]
		lxResult = lxResult + ccCR + ccLF + [Local loContextMenu as ContextMenu of <<lcQuote + tcFolder>>Source\Thor_Menu.vcx<<lcQuote>>]
		lxResult = lxResult + ccCR + ccLF + [loContextMenu|] + [<<ccClass + ' ContextMenu'>>]
		lxResult = lxResult + ccCR + ccLF + [Empty]
		*** DH 2018-04-10: new URL
		lxResult = lxResult + ccCR + ccLF + [* ThorFormSettings home page = https://github.com/VFPX/Thor/blob/master/Docs/Thor_framework_formsettings.md]
		lxResult = lxResult + ccCR + ccLF + [Local loSettings as Thor_Form_Settings of <<lcQuote + tcFolder>>Source\Thor_FoxResource.vcx<<lcQuote>>]
		lxResult = lxResult + ccCR + ccLF + [loSettings   |] + [<<ccClass + ' ThorFormSettings'>>]
		*!* * Removed 10/13/2011
		*!* lxResult = lxResult + ccCR + ccLF + [Empty]
		*!* lxResult = lxResult + ccCR + ccLF + [<<ccClass + ' FindEXE' xxxxxxxxxxxx>>]
		
		lxResult = lxResult + ccCR + ccLF + [Empty]
		lxResult = lxResult + ccCR + ccLF + [* Execute default procedure]
		lxResult = lxResult + ccCR + ccLF + [lxResult     |] + [<<ccDoDefault()>>]
		lxResult = lxResult + ccCR + ccLF + [Empty]
		lxResult = lxResult + ccCR + ccLF + [* Retrieve ThorInfo object for a Tool]
		lxResult = lxResult + ccCR + ccLF + [Local loThorInfo as ThorInfo of <<lcQuote + tcFolder>>Source\Thor_Utils.vcx<<lcQuote>>]
		lxResult = lxResult + ccCR + ccLF + [loThorInfo   |] + [<<ccToolInfo>>] + [" , ToolName) &] + [& e.g., "Thor_Tool_GoFish4]
		lxResult = lxResult + ccCR + ccLF + [Empty]
		lxResult = lxResult + ccCR + ccLF + [* Object used by APPs which self-register with Thor]
		lxResult = lxResult + ccCR + ccLF + [Local loRegister as Thorinfo of <<lcQuote + tcFolder>>Source\Thor_Utils.vcx<<lcQuote>>]
		lxResult = lxResult + ccCR + ccLF + [loRegister   |] + [<<ccTHORREGISTER>>]
		lxResult = lxResult + ccCR + ccLF + [Empty]
		lxResult = lxResult + ccCR + ccLF + [* Main Thor Engine]
		lxResult = lxResult + ccCR + ccLF + [Local loThor as Thor_Engine of <<lcQuote + tcFolder>>Source\Thor.vcx<<lcQuote>>]
		lxResult = lxResult + ccCR + ccLF + [loThor       |] + [<<ccTHORENGINE>>]
		
		lxResult = lxResult + ccCR + ccLF + [Empty]
		lxResult = lxResult + ccCR + ccLF + [* Retrieve sample tool template]
		lxResult = lxResult + ccCR + ccLF + [lcTemplate   |] + [<<ccTOOLTEMPLATE>>]
		
		lxResult = lxResult + ccCR + ccLF + [Empty]
		lxResult = lxResult + ccCR + ccLF + [<<ccRun>>]
		lxResult = lxResult + ccCR + ccLF + [Edit]
		lxResult = lxResult + ccCR + ccLF + [<<ccThorClearHotKeys>>]
		
		AddProperty (loResult, 'Internal', lxResult)
		
		lxResult = << lcPublishedClassesHelp >>
		AddProperty (loResult, 'External', lxResult)
		
		Return loResult
		Endtext
		
		****************************************************************
		lcPropertyName = 'cThorDispatcherHelp'
		Removeproperty (_Screen, lcPropertyName)
		
		_Screen.AddProperty (lcPropertyName, lcThorExecute)
		
	ENDPROC

	PROCEDURE clear		&& Clears the contents of a ComboBox or ListBox control.
		*==============================================================================
		* Method:			Clear
		* Purpose:			Clears out Thor, removing system menu
		* Author:			Jim Nelson
		* Last revision:	04/14/2011
		* Parameters:		none
		* Returns:			none
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		Set Sysmenu To Default
		
		
	ENDPROC

	PROCEDURE clearhotkeys		&& Removes all the Thor-assigned hotkeys
		Local loHotKeysCollection As 'Collection'
		Local lcFKYFile, lcFKYFileName, lcMacro, lcMacroName, lnCount, lnI, lnLength, lnNextByte
		Local lnTotalLength
		
		lcFKYFileName = Addbs (Sys(2023)) + Forceext (Sys(2015), 'FKY')
		This.EraseFile(lcFKYFileName)
		
		Save Macros To (lcFKYFileName)
		lcFKYFile = Filetostr (lcFKYFileName)
		This.EraseFile(lcFKYFileName)
		
		lnCount = (256 * Asc (Substr (lcFKYFile, 18))) + Asc (Substr (lcFKYFile, 17))
		
		loHotKeysCollection	= Createobject ('Collection')
		lnNextByte			= 19
		For lnI = 1 To lnCount
			lnLength	  = (256 * Asc (Substr (lcFKYFile, lnNextByte + 21))) + Asc (Substr (lcFKYFile, lnNextByte + 20))
			lnTotalLength = 24 + (2 * lnLength)
			lcMacro		  = Substr (lcFKYFile, lnNextByte, lnTotalLength)
			lnNextByte	  = lnNextByte + lnTotalLength
		
			lcMacroName = Left (lcMacro, 20)
			If Upper (lcMacroName) # Upper ('Thor:')
				loHotKeysCollection.Add (lcMacro)
			Endif
		Endfor && lnI = 1 to lnCount
		
		Clear Macros 
		This.AssignHotKeys (loHotKeysCollection)
		
		
		
		
	ENDPROC

	PROCEDURE createmacro
		*==============================================================================
		* Method:			CreateMacro
		* Purpose:			Creates the character string entry for a single macro (for a FKY file)
		* Author:			Jim Nelson
		* Last revision:	03/22/2011
		* Parameters:		tcMacroName			-- Name of the macro, up to length 20
		*					tcKeyCode			-- Internal (FKY) representation of key being defined (two bytes)
		*					tcLeadingKeystrokes -- Internal representation of leading keys in macro (two bytes each)
		*					tcCommand			-- Remainder of macro definition (normal character string)
		* Returns:			The macro text
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		Lparameters tcMacroName,  ;
			tcKeyCode,			  ;
			tcLeadingKeystrokes,  ;
			tcCommand
		
		Local lcCode, lcMacro, lcMacros, lnI
		
		lcMacros  = Padr (Trim (tcMacroName), 20, Chr(0)) +					  ;
			Chr (Len (tcCommand) + Len (tcLeadingKeystrokes) / 2) + Chr(0) +  ;
			tcKeyCode +														  ;
			tcLeadingKeystrokes
		
		For lnI = 1 To Len (tcCommand)
			lcMacros = lcMacros + Substr (tcCommand, lnI, 1) + Chr(0)
		Next lnI
		
		Return lcMacros
		
	ENDPROC

	PROCEDURE createtoolbar
		Local lcName, lcToolTip, lnI, loToolBar
		
		Select  *,									;
				Upper(Caption)    As  UCaption		;
			From ToolBarTools						;
			Where Enabled							;
			Order By UCaption, Order				;
			Into Cursor crsr_ToolBars Readwrite
		
		If _Tally = 0
			Return
		Endif
		
		If Type('_Screen.oThor_ToolBar') = 'O' And Vartype(_Screen.oThor_toolbar) = 'O'
			loToolBar = _Screen.oThor_toolbar
			For lnI = m.loToolBar.ControlCount To 1 Step - 1
				m.loToolBar.RemoveObject(m.loToolBar.Controls[m.lnI].Name)
			Endfor
		Else
			loToolBar = Newobject('Thor_ToolBar', 'Thor_Run.VCX', This.cApplication)
		Endif
		
		Select crsr_ToolBars
		Scan
			lcName = 'Button' + Transform(Recno())
			m.loToolBar.Newobject(m.lcName, 'Thor_ToolBar_Button', 'Thor_Run.VCX', This.cApplication)
			lcToolTip = Trim(ToolTip)
			If Seek(Upper(PRGName), 'ToolHotKeyAssignments', 'PRGName')
				If Seek(ToolHotKeyAssignments.HotKeyID, 'HotKeyDefinitions', 'ID')
					lcToolTip = m.lcToolTip + ' (' + Trim(HotKeyDefinitions.Descript) + ')'
				Endif
			Endif
			With m.loToolBar.&lcName
				.ToolTipText = m.lcToolTip
				.Picture	 = Trim(Icon)
				.Caption	 = Trim(Caption)
				.Visible	 = .T.
				.cAction	 = Trim(PRGName)
			Endwith
		Endscan
		
		If This.oThorEngine.GetOption ('ThorToolsBarDock0') And m.loToolBar.DockPosition # 0
			m.loToolBar.Dock(0)
		Endif
		m.loToolBar.Show()
		
		_Screen.AddProperty('oThor_ToolBar', m.loToolBar)
		
	ENDPROC

	PROCEDURE createtoplevelbars
		*==============================================================================
		* Method:			CreateTopLevelBars
		* Purpose:			Adds bars to all top level pads
		* Author:			Jim Nelson
		* Last revision:	03/21/2011
		* Parameters:		tcFolder ... folder for tools
		* Returns:			none
		* Environment in:	Table MenuDefinitions
		* Environment out:	none
		*==============================================================================
		
		Lparameters tcFolder
		Local loContextMenu As 'ContextMenu' Of 'Thor_Menu.vcx'
		Local laTopLevel[1], lcPopupName, lnI, loMenu
		
		Select  Id								 ;
			  , PopupName						 ;
			From MenuDefinitions				 ;
			Where TopLevel						 ;
				And  (PopupName = ccRunAllTools	 ;
				  Or Id In (					 ;
					Select  MenuID				 ;
						From MenuTools			 ;
						Where Not Deleted()))	 ;
				And Not Deleted()				 ;
			Into Array laTopLevel
		
		For lnI = 1 To _Tally
			lcPopupName	  = Alltrim (laTopLevel (lnI, 2))
			If lcPopupName = ccRunAllTools and not This.oThorEngine.GetOption ('ThorToolsSystemMenu')
				Loop
			EndIf 
			loContextMenu = Newobject ('ContextMenu', 'Thor_Menu.vcx', This.cThorApp, lcPopupName, 31416)
			If lcPopupName = ccRunAllTools
				This.AddAllTools (loContextMenu, tcFolder, , ) &&ccModify)
			Else
				This.AddMenuItems (loContextMenu, laTopLevel (lnI, 1), tcFolder)
			EndIf 
			loMenu = .Null.
		Endfor
		
		
	ENDPROC

	PROCEDURE createtoplevelpads
		*==============================================================================
		* Method:			CreateTopLevelPads
		* Purpose:			Cleans up previous top level pads, removing any user-defined pads,
		*					and removes all bars added to internal pads; then adds any user-defined pads
		* Author:			Jim Nelson
		* Last revision:	03/21/2011
		* Parameters:		none
		* Returns:			none
		* Environment in:	Table MenuDefinitions
		* Environment out:	none
		*==============================================================================
		
		Local lcKey, lcKeyx, lcLastPopupName, lcPopupName, lcPrompt, lcStatusBar, llSystemMenuPads
		
		*	This.Clear()
		
		*** JRN 5/17/2011 : system menu pads managed by other programs (VPM, e.g.)
		*	llSystemMenuPads = This.oThorEngine.GetOption ('SystemMenuPads')
		Select MenuDefinitions
		Set Order To Sortorder
		
		*** JRN 2011-06-19 : Wish I didn't have to do this ...
		Release Pad _PEMEditor Of _Msysmenu
		
		lcLastPopupName = ''
		
		Scan
			lcPrompt	= Alltrim(Prompt)
			lcPopupName	= Alltrim(PopupName)
			lcStatusBar	= Evl(Alltrim(StatusBar), 'Help not defined')
			Do Case
		
				Case Internal
					* remove all other entries			
					*!*				If Not llSystemMenuPads
					*!*					Release Bar All Of &lcPopupName
					*!*					Release Pad All Of &lcPopupName
					*!*				Endif
					lcLastPopupName = lcPopupName
		
				Case TopLevel
					* remove all other entries			
					Release Pad &lcPopupName Of _Msysmenu
		
					If lcPopupName = ccRunAllTools And Not This.oThorEngine.GetOption('ThorToolsSystemMenu')
						Loop
					Endif
					* and create the new entry, positioning as required
		
					lcKey = ''
					If '\<' $ lcPrompt
						lcKeyx = Substr(lcPrompt, At('\<', lcPrompt) + 2, 1)
						If Isalpha(lcKeyx) Or Isdigit(lcKeyx)
							lcKey = 'Key Alt+' + lcKeyx
						Endif
					Endif
		
					If Empty(lcLastPopupName)
						Define Pad &lcPopupName Of _Msysmenu Prompt lcPrompt &lcKey Before _Mfile Message(lcStatusBar)
					Else
						Define Pad &lcPopupName Of _Msysmenu Prompt lcPrompt &lcKey After &lcLastPopupName Message(lcStatusBar)
					Endif
		
					On Pad &lcPopupName Of _Msysmenu Activate Popup &lcPopupName
					Define Popup &lcPopupName Margin Relative Shadow Color Scheme 4
					lcLastPopupName = lcPopupName
		
				Otherwise
					* remove all other entries			
					Release Pad &lcPopupName Of _Msysmenu
		
			Endcase
		
		Endscan
		
	ENDPROC

	PROCEDURE Destroy
		Close Tables
		
	ENDPROC

	PROCEDURE erasefile
		Lparameters lcFileName
		
		Local loException
		Try
			Erase (m.lcFileName)
		Catch To m.loException
		
		Endtry
		
	ENDPROC

	PROCEDURE executepopup
		*==============================================================================
		* Method:			ExecutePopUp
		* Purpose:			Pops up a popup menu; called by hot key by way of ThorDispatcher
		* Author:			Jim Nelson
		* Last revision:	03/28/2011
		* Parameters:		lnMenuID			-- ID of the Menu in MenuDefinitions
		* Returns:			none
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		Lparameters lnMenuID, tcFolder, tnDataSession
		
		Local loContextMenu As 'ContextMenu' Of  'Thor_Menu.vcx'
		
		loContextMenu = Newobject ('ContextMenu', 'Thor_Menu.vcx', This.cThorApp)
		This.AddMenuItems (loContextMenu, lnMenuID, tcFolder + 'Tools\')
		
		loContextMenu.SetDataSession (tnDataSession)
		
		loContextMenu.Activate()
		
		
	ENDPROC

	PROCEDURE gethotkeyscollection
		Lparameters tcFolder
		Local loHotKeysCollection As 'Collection'
		
		loHotKeysCollection = Createobject ('Collection')
		
		This.AddToolHotKeys (tcFolder, loHotKeysCollection)
		This.AddPopUpHotKeys (loHotKeysCollection)
		
		Return loHotKeysCollection
	ENDPROC

	PROCEDURE getpublishedclasses
		Lparameters tlForHelp
		
		Local laClasses[1], laClasslist[1], lcAppName, lcClass, lcClassInfo, lcClassLib, lcFullAppName
		Local lcNewText, lcResult, lnCount, lnI, lnPos, loTool, loTools
		
		loTools = This.oToolsCollection
		
		Create Cursor crsr_Classes (AppName C(40), Class C(250), FullAPPName C(200), VarName C(40))
		For Each loTool In loTools FoxObject
			If Not Empty (loTool.Classes)
				lnCount = Alines (laClasses, loTool.Classes, .T., ',')
				For lnI = 1 To lnCount
					lcClass = laClasses (lnI)
					If '=' $ lcClass
						lnPos = At('=', lcClass)
						lcVariable = allTrim(Left(lcClass, lnPos - 1))
						lcClass = Alltrim(Substr(lcClass, lnPos + 1))
					Else
						lcVariable = ''
					EndIf 
					If tlForHelp
						*	lcClass = Lower (lcClass)
					Else
						lcClass = Lower (Getwordnum (lcClass, 1, '|'))
					Endif
					Insert Into crsr_Classes Values (Juststem (Lower (loTool.AppName)), lcClass, Lower (loTool.FullAPPName), lcVariable)
				Endfor
			Endif
		Endfor && each loTool in loTools foxobject
		
		Select  Distinct AppName  ;
		      , Class			  ;
		      , FullAPPName		  ;
		      , VarName           ;
		    From crsr_Classes	  ;
		    Into Array laClasslist
		
		lcResult = ''
		For lnI = 1 To _Tally
			lcClassInfo	  = Trim (laClasslist (lnI, 2))
			lcAppName	  = Evl(Juststem (Trim (laClasslist (lnI, 1))), JustFname(GetWordNum(lcClassInfo,3,' |'))) 
			lcFullAppName = Trim (laClasslist (lnI, 3))
			lcVariable    = Trim (laClasslist (lnI, 4))
		
			lcClass	   = Getwordnum (lcClassInfo, 1)
			lcClassLib = Getwordnum (lcClassInfo, Getwordcount (Class))
		
			Do Case
				*
				Case tlForHelp
					TEXT To lcNewText Textmerge Noshow
		+ ccCR + ccLF + [<<IIF(Empty(lcVariable), '', lcVariable + '||')>><<ccClass>> <<lcClass>> from <<Trim(lcAppName)>><<IIF('|' $ lcClassInfo, Substr(lcClassInfo, At('|', lcClassInfo)), '')>>]
					ENDTEXT
					If Empty (lcResult)
						lcResult = lcNewText
					Else
						lcResult = lcResult + ';' + ccCR + ccLF + Space(19) + lcNewText
					Endif
		
				*
				Case lcClass == 'tools' And lcAppName = 'pemeditor'
					TEXT To lcNewText Textmerge Noshow
			Case Lower(lcClassName) = '<<lcClass>> from <<lcAppName>>'
		   		ExecScript(_Screen.cThorDispatcher, 'PEMEditor_StartIDETools')
				Return _oPEMEditor.oTools
		
					ENDTEXT
					lcResult = lcResult + lcNewText
		
				*
				Case lcClass == 'editorwin' And lcAppName = 'pemeditor'
					TEXT To lcNewText Textmerge Noshow
			Case Lower(lcClassName) = '<<lcClass>> from <<lcAppName>>'
		   		ExecScript(_Screen.cThorDispatcher, 'PEMEditor_StartIDETools')
				loEditorWin = _oPEMEditor.oEditorWin
				loEditorWin.FindWindow()
				Return loEditorWin
		
					ENDTEXT
					lcResult = lcResult + lcNewText
		
			
				*
				Case Like('*_proc_*.prg', Lower(lcClassLib))  
					TEXT To lcNewText Textmerge Noshow
			Case Lower(lcClassName) = '<<lcClass>> from <<lcAppName>>'
				Return NewObject('<<lcClass>>',  _screen.cThorFolder + '\Tools\Procs\<<lcClassLib>>', '<<lcFullAppName>>')    			
		
					ENDTEXT
					lcResult = lcResult + lcNewText
		
				*
				Otherwise
					TEXT To lcNewText Textmerge Noshow
			Case Lower(lcClassName) = '<<lcClass>> from <<lcAppName>>'
				Return NewObject('<<lcClass>>', '<<lcClassLib>>', '<<lcFullAppName>>')    			
		
					ENDTEXT
					lcResult = lcResult + lcNewText
		
			Endcase
		Endfor
		
		Return lcResult
	ENDPROC

	PROCEDURE Init
		*==============================================================================
		* Method:			Init
		* Purpose:			Creates property .oThorEngine and opens all tables
		* Author:			Jim Nelson
		* Last revision:	03/28/2011
		* Parameters:		lnMenuID			-- ID of the Menu in MenuDefinitions
		*					tcFolder            -- folder for tools
		* Returns:			none
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		Lparameters tcThorApp, tcFolder
		
		With This
		
			.cThorApp	 = tcThorApp
			.cThorFolder = tcFolder
		
			.oThorEngine = Newobject ('Thor_Engine', 'Thor.vcx', tcThorApp, tcFolder)
			.oThorEngine.OpenTables()
			.oToolsCollection = .oThorEngine.GetToolsCollection (.cThorFolder + 'Tools\')
			
		Endwith
		
		Set Deleted On
		
	ENDPROC

	PROCEDURE popupalltools
		*==============================================================================
		* Method:			AddAllTools
		* Purpose:			For the internal sub-menu 'All Tools', adds ALL tools
		* Author:			Jim Nelson
		* Last revision:	04/14/2011
		* Parameters:		None
		* Returns:			none
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		Lparameters tnDataSession, tcOnlySource
		Local loContextMenu As 'ContextMenu' Of  'Thor_Menu.vcx'
		
		loContextMenu = Newobject ('ContextMenu', 'Thor_Menu.vcx', This.cThorApp)
		This.AddAllTools (loContextMenu, This.cThorFolder + 'Tools\', tcOnlySource)
		
		loContextMenu.SetDataSession (tnDataSession)
		
		loContextMenu.Activate()
		
	ENDPROC

	PROCEDURE run		&& Occurs when an Active Document is ready to execute your application code.
		*==============================================================================
		* Method:			Run
		* Purpose:			Assigns hot keys, creates pop-up menus, updates system menus, and all sub-menus
		* Author:			Jim Nelson
		* Last revision:	03/21/2011
		* Parameters:		llNoStartUps
		* Returns:			none
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		Lparameters llNoStartUps
		
		*	#Define WriteDebugInfo ShowDataSessions('Line ' + Transform(Lineno(1)))
		*	#Define WriteDebugInfo 
		lcFile = Sys(2023) + '\Thor_' + Sys(2015) + '.txt'
		lnSeconds = Seconds()
		
		With This
		
			*   WriteDebugInfo
			.AssignDedicatedHotKey()
		
			* Create _Screen.cThorDispatcher	
			*   WriteDebugInfo
			.AssignThorDispatcherHelp (.cThorApp, .cThorFolder)
			*   WriteDebugInfo
			.AssignThorDispatcherClasses (.cThorApp, .cThorFolder)
			*   WriteDebugInfo
			.AssignThorDispatcher (.cThorApp, .cThorFolder)
		
			* create all top level bars, removing traces of previously defined bars
			*   WriteDebugInfo
			.CreateTopLevelPads()
		
			* and then add in their tools and sub-menus
			*   WriteDebugInfo
			.CreateTopLevelBars (.cThorFolder + 'Tools\')
			
			* and all the hotkeys
			*   WriteDebugInfo
			.ClearHotKeys()
		
			* AGAIN -- so we can set up Debug Mode for dispatcher
			*   WriteDebugInfo
			.AssignThorDispatcher (.cThorApp, .cThorFolder)
		
			* Create Tool Bar
			.CreateToolBar()
		
			*   WriteDebugInfo
			.AssignAllHotKeys()
			
			*   WriteDebugInfo
			.UpdateOptionsList()
		
			* and run any startups
			*   WriteDebugInfo
			If not llNoStartUps
				.RunStartupPRGs
			EndIf 
		
			*   WriteDebugInfo
		
		Endwith
		
		
	ENDPROC

	PROCEDURE runstartupprgs
		*==============================================================================
		* Method:			RunStartupPRGS
		* Purpose:			Runs all of the startups (if any)
		* Author:			Jim Nelson
		* Last revision:	05/02/2011
		* Parameters:		none
		* Returns:			none
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		Select  PRGName		   ;
			from StartupTools  ;
			where Startup	   ;
			into cursor crsr_StartUps
			
		Scan
			ExecScript(_Screen.cThorDispatcher, Trim(PRGName), .T.)
		Endscan
		
		
	ENDPROC

	PROCEDURE updateoptionslist
		Local laClasses[1], lcClass, lcClassName, lcLibrary, lnCounter, lnI, lnJ, lnValue, loClass, loTool
		
		For lnI = 1 To This.oToolsCollection.Count
			loTool = This.oToolsCollection[lnI]
			If Not Empty(loTool.OptionClasses)
				lnCounter = Alines(laClasses, loTool.OptionClasses, 5, ',')
				For lnJ = 1 To lnCounter
					lcClass		= laClasses[lnJ]
					loClass		= Newobject(lcClass, loTool.FullFileName)
					lcClassName	= loClass.EditClassName
					Do Case
						Case Getwordcount(lcClassName) = 0
							lcLibrary	= ''
							lcClassName	= ''
						Case Getwordcount(lcClassName) = 1
							lcLibrary = loTool.FullFileName
						Otherwise
							lcLibrary	= Execscript(_Screen.cThorDispatcher, 'Full Path=' + Getwordnum(lcClassName, Getwordcount(lcClassName)))
							lcClassName	= Getwordnum(lcClassName, 1)
					Endcase
		
					Do Case
						Case Not This.oThorEngine.FindOption(loClass.Key, loClass.Tool)
							Insert Into Thor(Key, Tool, Class, Library)			;
								Values											;
								(loClass.Key, loClass.Tool, lcClassName, lcLibrary)
							If Pemstatus(loClass, 'Value', 5)
								This.oThorEngine.SetOption(loClass.Key, loClass.Tool, loClass.Value)
							Else
								This.oThorEngine.SetOption(loClass.Key, loClass.Tool, Null)
							Endif
		
						Case Upper(Thor.Class) == Upper(lcClassName)		;
								And Upper(Thor.Library) == Upper(lcLibrary)
		
						Otherwise
							Replace	Class	 With  lcClassName		;
									Library	 With  lcLibrary		;
								In Thor
					Endcase
				Endfor
			Endif
		Endfor && lnI = 1 to This.oToolsCollection.Count
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS thor_toolbar AS toolbar 
 	*< CLASSDATA: Baseclass="toolbar" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: savesettings
		*p: ndockposition
		*p: osettings
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		Caption = "THOR Quick Access"
		DataSession = 2
		Left = 0
		Name = "thor_toolbar"
		ndockposition = 0
		osettings = .NULL.
		Top = 0
		_memberdata = <VFPData>
			<memberdata name="osettings" display="oSettings"/>
			<memberdata name="ndockposition" display="nDockPosition"/>
			<memberdata name="savesettings" display="SaveSettings"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE AfterDock
		This.SaveSettings()
		
	ENDPROC

	PROCEDURE Destroy
		This.SaveSettings()
		This.oSettings = .Null.
		Close Tables
		
	ENDPROC

	PROCEDURE Init
		*** 2018-04-10: new URL
		* ThorFormSettings home page = https://github.com/VFPX/Thor/blob/master/Docs/Thor_framework_formsettings.md
		Local loSettings as Thor_Form_Settings of 'C:\VISUAL FOXPRO\PROGRAMS\9.0\COMMON\Thor\Source\Thor_FoxResource.vcx'
		Set Talk Off 
		loSettings    = ExecScript(_Screen.cThorDispatcher, "Class= ThorFormSettings", 'ThorToolBar')
		
		lnSelect = Select()
		loSettings.Restore(This)
		loSettings.Restore(This, 'nDockPosition')
		If This.nDockPosition >= 0
			This.Dock(This.nDockPosition)
		EndIf
		
		This.oSettings = loSettings
		Select (lnSelect)
		
	ENDPROC

	PROCEDURE Moved
		This.SaveSettings()
		
	ENDPROC

	PROCEDURE savesettings
		If Type('This.oSettings') = 'O' And Vartype(This.oSettings) = 'O'
			This.nDockPosition = This.DockPosition 
			This.oSettings.Save (This)
		Endif
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS thor_toolbar_button AS commandbutton 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: caption_assign
		*m: picture_assign
		*p: caction
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		caction = 
		Caption = ""
		FontSize = 8
		Height = 24
		Name = "thor_toolbar_button"
		Picture = 
		SpecialEffect = 2
		Width = 24
		_memberdata = <VFPData>
			<memberdata name="caction" display="cAction"/>
			<memberdata name="caption" display="Caption"/>
			<memberdata name="caption_assign" display="Caption_Assign"/>
			<memberdata name="picture" display="Picture"/>
			<memberdata name="picture_assign" display="Picture_Assign"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE caption_assign
		Lparameters tCaption
		This.Caption = tCaption
		
		If Empty(tCaption)
			Return
		Endif
		
		With This
			.AutoSize = .T.
			.AutoSize = .F.
			.Width	  = .Width - 7
			.Height	  = 22
		Endwith
	ENDPROC

	PROCEDURE Click
		Set Datasession to 1
		ExecScript(_Screen.cThorDispatcher, This.cAction)
		
	ENDPROC

	PROCEDURE picture_assign
		lparameters tPicture
		This.Picture = tPicture
		
		This.Height = 22
		This.Width = 24
	ENDPROC

	PROCEDURE RightClick
		Execscript (_Screen.cThorDispatcher, 'Thor_Proc_EditProc', This.cAction)
	ENDPROC

ENDDEFINE

DEFINE CLASS thor_toolbar_separator AS separator 
 	*< CLASSDATA: Baseclass="separator" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<PropValue>
		Height = 0
		Left = 0
		Name = "thorseparator"
		Style = 0
		Top = 0
		Width = 0
	*</PropValue>

ENDDEFINE
