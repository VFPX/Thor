*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="basecontrols.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS basecheckbox AS checkbox 
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		Alignment = 0
		AutoSize = .T.
		BackStyle = 0
		Caption = "Check1"
		FontName = "Tahoma"
		FontSize = 10
		Name = "basecheckbox"
		Value = .F.
		_memberdata = <VFPData>
			<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
			<memberdata name="lupdatecontrolsourceonchange" type="property" display="lUpdateControlSourceOnChange" favorites="True"/>
			<memberdata name="updatecontrolsource" display="UpdateControlSource"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method
		
	ENDPROC

	PROCEDURE InteractiveChange
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
		
		* Update the control source in case AnyChange calls Refresh.
		
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not empty(.ControlSource) and ;
				not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		
		* Call a common method for handling changes.
		
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Call a common method for handling changes.
		
		This.AnyChange()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basecollection AS collection 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		Height = 23
		Name = "buildercollection"
		Width = 23
		_memberdata = <VFPData>

		</VFPData>
	*</PropValue>

ENDDEFINE

DEFINE CLASS basecombobox AS combobox 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*a: aitems[1,0]		&& An array of items for the RowSource if RowSourceType is set to 5-Array
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		FontName = "Tahoma"
		FontSize = 10
		Height = 22
		ItemTips = .T.
		Name = "basecombobox"
		RowSource = "This.aItems"
		RowSourceType = 5
		Style = 2
		_memberdata = <VFPData>
			<memberdata name="aitems" type="property" display="aItems"/>
			<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE DropDown
		* Set DisplayCount to an appropriate value based on how much room there is
		* below the form.
		
		local lnHeight
		lnHeight = iif(Thisform.ShowWindow = 2 or ;
			(pemstatus(Thisform, 'Desktop', 5) and Thisform.Desktop), sysmetric(2), ;
			_vfp.Height)
		This.DisplayCount = max(ceiling((lnHeight - Thisform.Top - ;
			objtoclient(This, 1))/This.Height), 7)
		
	ENDPROC

	PROCEDURE Init
		* Initialize aItems.
		
		This.aItems = ''
		
	ENDPROC

	PROCEDURE InteractiveChange
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
		
		* Update the control source in case AnyChange calls Refresh.
		
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not empty(.ControlSource) and ;
				not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		
		* Call a common method for handling changes.
		
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Call a common method for handling changes.
		
		This.AnyChange()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basecommandbutton AS commandbutton 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		Caption = "Command1"
		FontName = "Tahoma"
		FontSize = 10
		Height = 23
		Name = "basecommandbutton"
		Width = 75
		_memberdata = <VFPData>

		</VFPData>
	*</PropValue>

ENDDEFINE

DEFINE CLASS basecontainer AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: enabled_assign
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		BackStyle = 0
		BorderWidth = 0
		Name = "basecontainer"
		Style = 3
		_memberdata = <VFPData>

		</VFPData>
	*</PropValue>
	
	PROCEDURE enabled_assign
		lparameters tlEnabled
		This.Enabled = tlEnabled
		This.SetAll('Enabled', tlEnabled)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseeditbox AS editbox 
 	*< CLASSDATA: Baseclass="editbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*m: validation		&& Custom validation code
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		FontName = "Tahoma"
		FontSize = 10
		IntegralHeight = .T.
		Name = "baseeditbox"
		SelectOnEntry = .T.
		_memberdata = <VFPData>
			<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
			<memberdata name="lupdatecontrolsourceonchange" type="property" display="lUpdateControlSourceOnChange" favorites="True"/>
			<memberdata name="validation" type="method" display="Validation" favorites="True"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Call a common method for handling changes.
		
		This.AnyChange()
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Call a common method for handling changes.
		
		This.AnyChange()
		
	ENDPROC

	PROCEDURE Valid
		* If we're not canceling, call the Validation method to do the actual
		* validation.
		
		local luReturn
		with This
			if lastkey() <> 27
				luReturn = .Validation()
			else
				luReturn = .T.
			endif lastkey() <> 27
		endwith
		return luReturn
		
	ENDPROC

	PROCEDURE validation		&& Custom validation code
		* Abstract method
		
	ENDPROC

	PROCEDURE When
		* Store the current value into the Tag property so it can be restored if Valid
		* fails.
		
		This.Tag = This.Value
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseform AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdEscape" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: refreshform		&& Refreshes the form with the LockScreen .T.
		*m: restoresettings		&& Restores saved settings from FOXUSER
		*m: savesettings		&& Saves settings to FOXUSER
		*m: setfocustofirstobject		&& Sets focus to the first object in the specified container
		*p: cfoxuserid		&& The FOXUSER ID to save/restore settings to
		*p: cfoxusername		&& The FOXUSER NAME to save/restore settings to
		*p: ldockable
		*p: lpersistsizeposition		&& .T. to persist the size and position of the form
		*p: lsavesettings		&& .T. to save and restore settings
		*p: lsavetopwidth
		*p: opersist		&& A reference to a FoxResource object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		AllowOutput = .F.
		AutoCenter = .T.
		Caption = "Form"
		cfoxuserid = 
		cfoxusername = 
		DataSession = 2
		DoCreate = .T.
		FontName = "Tahoma"
		FontSize = 10
		ldockable = .F.
		lpersistsizeposition = .T.
		lsavesettings = .T.
		lsavetopwidth = .T.
		Name = "baseform"
		opersist = .NULL.
		ShowTips = .T.
		Visible = .T.
		_memberdata = <VFPData>
			<memberdata name="cfoxuserid" type="property" display="cFoxUserID" favorites="True"/>
			<memberdata name="cfoxusername" type="property" display="cFoxUserName" favorites="True"/>
			<memberdata name="lpersistsizeposition" type="property" display="lPersistSizePosition" favorites="True"/>
			<memberdata name="lsavesettings" type="property" display="lSaveSettings" favorites="True"/>
			<memberdata name="opersist" type="property" display="oPersist"/>
			<memberdata name="refreshform" type="method" display="RefreshForm"/>
			<memberdata name="restoresettings" type="method" display="RestoreSettings" favorites="True"/>
			<memberdata name="savesettings" type="method" display="SaveSettings" favorites="True"/>
			<memberdata name="setfocustofirstobject" display="SetFocusToFirstObject"/>
			<memberdata name="ldockable" display="lDockable"/>
			<memberdata name="lsavetopwidth" display="lSaveTopWidth"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'cmdEscape' AS basecommandbutton WITH ;
		Cancel = .T., ;
		Left = -100, ;
		Name = "cmdEscape", ;
		Top = -100
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="commandbutton" />
	
	PROCEDURE Destroy
		* Save the current settings
		
		if This.lSaveSettings
			This.SaveSettings()
		endif This.lSaveSettings
		
		* Nuke member objects.
		
		This.oPersist = .NULL.
		
	ENDPROC

	PROCEDURE Init
		local lcLibrary
		with This
		
		* Restore saved options and the size and position of the form.
		
			if .lSaveSettings
				lcLibrary = 'FoxResource.prg'
				.oPersist = newobject('FoxResource', lcLibrary)
				.RestoreSettings()
			endif .lSaveSettings
		endwith
		
	ENDPROC

	PROCEDURE Load
		* Set up the environment.
		
		set deleted on
		set exact off
		set exclusive off
		set multilocks on
		set safety off
		set talk off
		
		
	ENDPROC

	PROCEDURE refreshform		&& Refreshes the form with the LockScreen .T.
		* Lock for form while refreshing.
		
		LockWindow(.T.)
		
		This.LockScreen = .T.
		This.Refresh()
		This.LockScreen = .F.
		
		LockWindow(.F.)
	ENDPROC

	PROCEDURE restoresettings		&& Restores saved settings from FOXUSER
		* Restore saved settings from FOXUSER.
		
		Local lnDockable, lnHeight, lnLeft, lnTop, lnWidth
		With This
			.oPersist.Load (.cFoxUserID, .cFoxUserName)
			
			If .lPersistSizePosition
				lnDockable = Nvl (.oPersist.Get ('Dockable'), 1)
				lnTop	   = Max (Nvl (.oPersist.Get ('Top'),  .Top),  0)
				lnLeft	   = Max (Nvl (.oPersist.Get ('Left'), .Left), 0)
				lnHeight   = Nvl (.oPersist.Get ('Height'),   .Height)
				lnWidth	   = Nvl (.oPersist.Get ('Width'),    .Width)
		
				.Top	  = -2000
				If .lDockable
					.Dockable = lnDockable
				Endif
		
				.Left	= lnLeft
				.Height	= lnHeight
				.Width	= lnWidth
				* Setting Top must be last so that it 
				*   does not become visible until now
				.Top	= lnTop
			Endif .lPersistSizePosition
		Endwith
		
	ENDPROC

	PROCEDURE savesettings		&& Saves settings to FOXUSER
		* Save settings to FOXUSER.
		
		with This
			if .lPersistSizePosition
				.oPersist.Set('Dockable',    .Dockable)
				.oPersist.Set('Top',    .Top)
				.oPersist.Set('Left',   .Left)
				.oPersist.Set('Height', .Height)
				.oPersist.Set('Width',  .Width)
			endif .lPersistSizePosition
			.oPersist.Save(.cFoxUserID, .cFoxUserName)
		endwith
		
	ENDPROC

	PROCEDURE setfocustofirstobject		&& Sets focus to the first object in the specified container
		*==============================================================================
		* Method:			SetFocusToFirstObject
		* Status:			Public
		* Purpose:			Sets focus to the first object in the specified container
		* Author:			Doug Hennig
		* Last revision:	09/24/2010
		* Parameters:		toContainer       - the container to check (optional: if it
		*						isn't passed, the form is used)
		*					tlKeepCurrentPage - .T. to keep the current page in any
		*						PageFrame active
		* Returns:			.T. if it set focus to an object
		* Environment in:	none
		* Environment out:	if this method returns .T., focus has been set to an object
		*==============================================================================
		
		lparameters toContainer, ;
			tlKeepCurrentPage
		local loContainer, ;
			laObjects[1], ;
			lnObjects, ;
			lnIndex, ;
			loControl, ;
			llReturn, ;
			lnI, ;
			loObject, ;
			lcClass, ;
			lnPage, ;
			loPage
		
		* If the container wasn't specified, let's use the form.
		
		loContainer = iif(vartype(toContainer) = 'O', toContainer, This)
		
		* Get an array of all member objects of the specified container. Initialize
		* some variables.
		
		lnObjects = amembers(laObjects, loContainer, 2)
		lnIndex   = 99999
		loControl = .NULL.
		llReturn  = .F.
		
		* Check each of the member objects until we come across the one lowest in the
		* tab order.
		
		for lnI = 1 to lnObjects
			loObject = evaluate('loContainer.' + laObjects[lnI])
			lcClass  = upper(loObject.BaseClass)
			do case
		
		* If the object doesn't have a TabIndex property, is a label, is disabled, is
		* read-only, or isn't visible, ignore it.
		
				case type('loObject.TabIndex') = 'U' or lcClass = 'LABEL' or ;
					(type('loObject.TabStop') = 'L' and not loObject.TabStop and ;
						upper(loObject.BaseClass) <> 'PAGEFRAME') or ;
					(type('loObject.Enabled') = 'L' and not loObject.Enabled) or ;
					(type('loObject.ReadOnly') = 'L' and loObject.ReadOnly) or ;
					(type('loObject.Visible') = 'L' and not loObject.Visible)
		
		* If this object is lower in tab order than any we've already seen, grab a
		* reference to it.
		
				case loObject.TabIndex < lnIndex
					loControl = loObject
					lnIndex   = loObject.TabIndex
			endcase
		next lnI
		
		* If we found an object, set focus to it. We may need to drill down into it if
		* it's a container.
		
		if vartype(loControl) = 'O'
			lcClass = upper(loControl.BaseClass)
			do case
		
		* If this is a pageframe, choose the first page, then call ourselves
		* recursively to find the first object inside it and set focus to it.
		
				case lcClass = 'PAGEFRAME'
					if tlKeepCurrentPage
						lnPage = loControl.ActivePage
					else
						lnIndex = 99999
						lnPage  = 0
						for lnI = 1 to loControl.PageCount
							try
								loPage = loControl.Pages[lnI]
								if loPage.PageOrder < lnIndex
									lnPage  = lnI
									lnIndex = loPage.PageOrder
								endif loPage.PageOrder < lnIndex
							catch
							endtry
						next lnI
					endif tlKeepCurrentPage
					if lnPage > 0
						if loControl.ActivePage <> lnPage
							loControl.ActivePage = lnPage
						endif loControl.ActivePage <> lnPage
						llReturn = This.SetFocusToFirstObject(loControl.Pages[lnPage])
					endif lnPage > 0
		
		* If this is another type of container, call ourselves recursively to find the
		* first object inside it and set focus to it.
		
				case lcClass $ 'COMMANDGROUP,OPTIONGROUP,CONTAINER'
					llReturn = This.SetFocusToFirstObject(loControl)
		
		* Set focus to the object.
		
				case pemstatus(loControl, 'SetFocus', 5)
					loControl.SetFocus()
					llReturn = .T.
			endcase
		endif vartype(loControl) = 'O' ...
		return llReturn
		
	ENDPROC

	PROCEDURE cmdEscape.Click
		Thisform.Release()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basegrid AS grid 
 	*< CLASSDATA: Baseclass="grid" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<PropValue>
		FontName = "Tahoma"
		FontSize = 10
		Height = 200
		Name = "basegrid"
		RowHeight = 19
		Width = 320
	*</PropValue>

ENDDEFINE

DEFINE CLASS baselabel AS label 
 	*< CLASSDATA: Baseclass="label" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		AutoSize = .T.
		BackStyle = 0
		Caption = "Label1"
		FontName = "Tahoma"
		FontSize = 10
		Name = "baselabel"
		_memberdata = <VFPData>

		</VFPData>
	*</PropValue>

ENDDEFINE

DEFINE CLASS baselabelledbox AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="shpBox" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblBox" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: height_assign
		*m: width_assign
		*p: builder		&& Specifies the builder for this object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		BackStyle = 0
		BorderWidth = 0
		builder = BaseLabelledBoxBuilder.PRG
		Height = 133
		Name = "baselabelledbox"
		Style = 3
		Width = 168
		_memberdata = <VFPData>
			<memberdata name="builder" type="property" display="Builder"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'lblBox' AS baselabel WITH ;
		BackStyle = 1, ;
		Left = 10, ;
		Name = "lblBox", ;
		Style = 3
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'shpBox' AS baseline3d WITH ;
		Height = 124, ;
		Name = "shpBox", ;
		Top = 7, ;
		Width = 166
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="shape" />
	
	PROCEDURE height_assign
		* When the height of the container is resized, resize the shape.
		
		lparameters tnHeight
		This.Height = tnHeight
		This.shpBox.Height = tnHeight - This.shpBox.Top
		
	ENDPROC

	PROCEDURE width_assign
		* When the width of the container is resized, resize the shape.
		
		lparameters tnWidth
		store tnWidth to This.Width, This.shpBox.Width
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseline3d AS shape 
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		BackStyle = 0
		Height = 1
		Name = "baseline3d"
		SpecialEffect = 0
		Style = 3
		Width = 100
		_memberdata = <VFPData>

		</VFPData>
	*</PropValue>

ENDDEFINE

DEFINE CLASS baselistbox AS listbox 
 	*< CLASSDATA: Baseclass="listbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*a: aitems[1,0]		&& An array of items for the RecordSource
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		FontName = "Tahoma"
		FontSize = 10
		IntegralHeight = .T.
		ItemTips = .T.
		Name = "baselistbox"
		RowSource = "This.aItems"
		RowSourceType = 5
		_memberdata = <VFPData>
			<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
			<memberdata name="aitems" display="aItems"/>
			<memberdata name="rowsource" display="RowSource"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE InteractiveChange
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
		
		* Update the control source in case AnyChange calls Refresh.
		
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not empty(.ControlSource) and ;
				not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		
		* Call a common method for handling changes.
		
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Call a common method for handling changes.
		
		This.AnyChange()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseoptionbutton AS optionbutton 
 	*< CLASSDATA: Baseclass="optionbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		AutoSize = .T.
		BackStyle = 0
		Caption = "Option1"
		FontName = "Tahoma"
		FontSize = 10
		Name = "baseoptionbutton"
		_memberdata = <VFPData>

		</VFPData>
	*</PropValue>
	
	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseoptiongroup AS optiongroup 
 	*< CLASSDATA: Baseclass="optiongroup" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		BackStyle = 0
		BorderStyle = 0
		ButtonCount = 2
		Height = 46
		MemberClass = "baseoptionbutton"
		MemberClassLibrary = basecontrols.vcx
		Name = "baseoptiongroup"
		Value = 0
		Width = 71
		_memberdata = <VFPData>
			<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		</VFPData>
		Baseoptionbutton1.Left = 5
		Baseoptionbutton1.Name = "Baseoptionbutton1"
		Baseoptionbutton1.Top = 5
		Baseoptionbutton2.Left = 5
		Baseoptionbutton2.Name = "Baseoptionbutton2"
		Baseoptionbutton2.Top = 23
	*</PropValue>
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE InteractiveChange
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
		
		* Update the control source in case AnyChange calls Refresh.
		
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not empty(.ControlSource) and ;
				not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		
		* Call a common method for handling changes.
		
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Call a common method for handling changes.
		
		This.AnyChange()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basepage AS page 
 	*< CLASSDATA: Baseclass="page" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		Caption = "Page1"
		FontName = "Tahoma"
		FontSize = 10
		Height = 139
		Name = "basepage"
		Width = 139
		_memberdata = <VFPData>

		</VFPData>
	*</PropValue>
	
	PROCEDURE Activate
		* Refresh all controls.
		
		LockWindow(.T.)
		
		local llLockScreen
		with This
			llLockScreen = Thisform.LockScreen
			if not llLockScreen
				Thisform.LockScreen = .T.
			endif not llLockScreen
			.Refresh()
			if not llLockScreen
				Thisform.LockScreen = .F.
			endif not llLockScreen
		endwith
		
		LockWindow(.F.)
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basepageframe AS pageframe 
 	*< CLASSDATA: Baseclass="pageframe" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		ErasePage = .T.
		Height = 250
		MemberClass = "basepage"
		MemberClassLibrary = basecontrols.vcx
		Name = "basepageframe"
		PageCount = 1
		TabStyle = 1
		_memberdata = <VFPData>

		</VFPData>
		Basepage1.Name = "Basepage1"
	*</PropValue>

ENDDEFINE

DEFINE CLASS baseshape AS shape 
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<PropValue>
		BackStyle = 0
		Height = 17
		Name = "baseshape"
		Width = 100
	*</PropValue>

ENDDEFINE

DEFINE CLASS basespinner AS spinner 
 	*< CLASSDATA: Baseclass="spinner" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		FontName = "Tahoma"
		FontSize = 10
		Height = 24
		Name = "basespinner"
		SelectOnEntry = .T.
		_memberdata = <VFPData>
			<memberdata name="anychange" type="method" display="AnyChange"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE Error
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		do case
		
		* Spinners bound to object properties seem to have a problem when invalid
		* values are entered from the keyboard: the Error method fires with error 1469
		* (property value is out of bounds) with tcMethod being "ControlSource" rather
		* than the Valid method catching it.
		
			case tnError = 1469
				return
		
		* Ignore "property is read-only" errors.
		
			case tnError = 1743
				return
		
		* All other errors get passed on to the form.
		
			otherwise
				Thisform.Error(tnError, This.Name + '.' + tcMethod, tnLine)
		endcase
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Write the current value to the ControlSource if necessary (otherwise
		* anything called from here can't check the value of our ControlSource), call
		* the AnyChange method. Note: if the value is invalid, don't do anything.
		
		local lnPos, ;
			lcAlias, ;
			lcField
		
		if not between(This.Value, This.SpinnerLowValue, This.SpinnerHighValue)
			nodefault
			return
		endif not between(.Value, ...
		
		with This
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not empty(.ControlSource) and ;
				not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				try
					if used(lcAlias)
						replace (lcField) with .Value in (lcAlias)
					else
						store .Value to (.ControlSource)
					endif used(lcAlias)
				catch
					nodefault
				endtry
			endif lnPos > 0 ...
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Call a common method for handling changes.
		
		This.AnyChange()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basetextbox AS textbox 
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*m: validation		&& Custom validation code
		*p: conentryvalue		&& The value when the textbox receives focus
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		conentryvalue = 
		FontName = "Tahoma"
		FontSize = 10
		Format = "T"
		Height = 22
		Name = "basetextbox"
		SelectOnEntry = .T.
		_memberdata = <VFPData>
			<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
			<memberdata name="lupdatecontrolsourceonchange" type="property" display="lUpdateControlSourceOnChange" favorites="True"/>
			<memberdata name="validation" type="method" display="Validation" favorites="True"/>
			<memberdata name="conentryvalue" display="cOnEntryValue"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE GotFocus
		* Save the value in case we need to restore it later.
		
		This.cOnEntryValue = This.Value
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Call a common method for handling changes.
		
		This.AnyChange()
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Call a common method for handling changes.
		
		This.AnyChange()
		
	ENDPROC

	PROCEDURE Valid
		* If we're not canceling, call the Validation method to do the actual
		* validation.
		
		local luReturn
		with This
			if lastkey() <> 27
				luReturn = .Validation()
			else
				luReturn = .T.
			endif lastkey() <> 27
		endwith
		return luReturn
		
	ENDPROC

	PROCEDURE validation		&& Custom validation code
		* Abstract method
		
	ENDPROC

	PROCEDURE When
		* Store the current value into the Tag property so it can be restored if Valid
		* fails.
		
		This.Tag = This.Value
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basetree AS olecontrol 
 	*< CLASSDATA: Baseclass="olecontrol" Timestamp="" Scale="Pixels" Uniqueid="" Nombre="basetree" Parent="" ObjName="basetree" OLEObject="C:\Windows\SysWOW64\MSCOMCTL.OCX" Value="0M8R4KGxGuEAAAAAAAAAAAAAAAAAAAAAPgADAP7/CQAGAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAEAAAAgAAAAEAAAD+////AAAAAAAAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9/////v////7////+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1IAbwBvAHQAIABFAG4AdAByAHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAUA//////////8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFD6IW88UM0BAwAAAEABAAAAAAAAAwBPAGwAZQBPAGIAagBlAGMAdABEAGEAdABhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4AAgEDAAAAAgAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAagAAAAAAAAADAEEAYwBjAGUAcwBzAE8AYgBqAFMAaQB0AGUARABhAHQAYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJgACAP///////////////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAABcAAAAAAAAAAMAQwBoAGEAbgBnAGUAZABQAHIAbwBwAHMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAIA////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAQAAAAAAAAABAAAAAIAAAD+/////v////7///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+2kEHHiYXREbFqAMDwKDYoIUM0EggAAABWCgAAVgoAALE8wWoBAAYAIgAAAJwAAADoAwAACAAAAAEAAAAB782rXAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAACQAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5MzY4MjY1RS04NUZFLTExZDEtOEJFMy0wMDAwRjg3NTREQTEAAAAAAAAAAAEAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAABAACAAAAAAAAAAAAFAAEARIfQAAAAAAAGABwBWQEMANgGLgAUIgqrAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFADAxUwgGAAAAAAAAAAUAAICE6xgAAQAAAFwAH97svQEABQDM6xgAAAAGAAAAAAAAAAAAAADbIQrrAAAAAAAAAAABAAAAAQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQABANSV0AAAAAAAKwAwAXUACADQAhUA0AIVAAAAkgW+MIF8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE8ARQBcAFQATQBBAFMAXwBPAEUASABvAA==" />

	*<DefinedPropArrayMethod>
		*m: getitemkey
		*m: loadchildnodes
		*m: loadnode
		*m: loadtree
		*m: restoreexpandednodes
		*m: saveexpandednodes
		*p: cselectednode
		*a: anodes[1,0]
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		cselectednode = 
		Height = 100
		Name = "basetree"
		Width = 100
		_memberdata = <VFPData>
			<memberdata name="anodes" display="aNodes"/>
			<memberdata name="cselectednode" display="cSelectedNode"/>
			<memberdata name="saveexpandednodes" display="SaveExpandedNodes"/>
			<memberdata name="restoreexpandednodes" display="RestoreExpandedNodes"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE getitemkey
	ENDPROC

	PROCEDURE loadchildnodes
	ENDPROC

	PROCEDURE loadnode
	ENDPROC

	PROCEDURE loadtree
	ENDPROC

	PROCEDURE restoreexpandednodes
		Local lcKey, lnI, lnPos, loNode, loSelected
		loSelected = .Null.
		With This
			For lnI = 1 To .Nodes.Count
				loNode = .Nodes.Item[lnI]
				lcKey  = loNode.Key
				lnPos  = Ascan (.aNodes, lcKey, -1, -1, 1, 15)
				If lnPos > 0
					loNode.Expanded = .aNodes[lnPos, 2]
					If lcKey == .cSelectedNode
						.SelectedItem = loNode
						loNode.EnsureVisible()
						loSelected = loNode
					Endif lcKey == .cSelectedNode
				Endif lnPos > 0 ...
			Next lnI
		Endwith && this
		
		Return loSelected
		
		
	ENDPROC

	PROCEDURE saveexpandednodes
		Local lnI, loNode
		Local aNodes[1]
		With This
			Dimension .aNodes[.Nodes.Count, 2]
			For lnI = 1 To .Nodes.Count
				loNode = .Nodes.Item[lnI]
				.aNodes[lnI, 1] = loNode.Key
				.aNodes[lnI, 2] = loNode.Expanded
			Next lnI
			Try
				.cSelectedNode = .SelectedItem.Key
			Catch
			EndTry
			.Nodes.Clear()
		Endwith && This
		
		
	ENDPROC

ENDDEFINE
