*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="thor.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS othor AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "thor.h"
	*<DefinedPropArrayMethod>
		*m: do
		*m: executethorproc
		*m: getfullfilename
		*p: cappfolder
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		cappfolder = .F.
		Name = "othor"
		_memberdata = <VFPData>
			<memberdata name="do" display="Do"/>
			<memberdata name="executethorproc" display="ExecuteThorProc"/>
			<memberdata name="getfullfilename" display="GetFullFileName"/>
			<memberdata name="cappfolder" display="cAppFolder"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE do
		LParameters lcPRGName, lxP1, lxP2, lxP3, lxP4, lxP5, lxP6, lxP7, lxP8, lxP9, lxP10
		
		Local loGetThor As 'GetThorRun'
		Local lcFile, lcFolder, lcSys16, lcThorApp, lcThorFolder, llFirst, llThorInkey, lnI, lnInkey, lnPopUpID
		Local lnWindowOnTop, loLink, loPEME_Tools, loResult, loThorEngine, loThorInfo, loThorRun
		
		lcFolder	 = This.cAppFolder
		lcThorApp	 = lcFolder + 'Thor.APP'
		lcThorFolder = lcFolder + 'Thor\' 
		llThorInkey = .F.
		
		Do Case
			Case Atc('Thor_', lcPrgName) = 1 
				Return This.ExecuteThorProc(lcPRGName, lcThorFolder, llThorInkey, .F., Pcount(), @lxP1, @lxP2, @lxP3, @lxP4, @lxP5, @lxP6, @lxP7, @lxP8, @lxP9, @lxP10)
		
			Case Atc([Full Path=], lcPrgName) = 1
				lcFile         = This.GetFullFileName (Alltrim (Substr (lcPRGName, At ('=', lcPRGName) + 1)), lcThorFolder)
				Return lcFile
		
			Case Atc([Class=], lcPrgName) = 1
				Return ExecScript(_Screen.cThorNewObject, lcPRGName, lcThorAPP, Pcount(), lxP1, lxP2, lxP3, lxP4, lxP5)
		
			Case Atc([PopupID=], lcPrgName) = 1
				Return ExecScript(_Screen.cThorDispatcher, lcPrgName)
		
			Case Atc([Result=], lcPrgName) = 1
				_Screen.xThorResult	= lxP1
				Return lxP1
		
			Case Empty (lcPRGName)
				Do (lcThorApp) With 'Edit'
		
			Case Atc([FORMRUNTOOL], lcPrgName) = 1
				Do (lcThorApp) With 'FORMRUNTOOL'
		
			Case Atc([?], lcPrgName) = 1
				Return ExecScript(_Screen.cThorFramework)
		
			Case Atc([Run], lcPrgName) = 1
				Return ExecScript(_Screen.cThorDispatcher, lcPrgName)
		
			Case Atc([Tool Folder=], lcPrgName) = 1
				Return lcThorFolder + 'Tools\'
		
			Case Atc([Version=], lcPrgName) = 1
				Return ExecScript(_Screen.cThorDispatcher, lcPrgName)
		
			Case Atc([Thor Engine=], lcPrgName) = 1
				Return ExecScript(_Screen.cThorDispatcher, lcPrgName)
		
			Case Atc([Thor Register=], lcPrgName) = 1
				Return ExecScript(_Screen.cThorDispatcher, lcPrgName)
		
			Case Atc([Get Option=], lcPrgName) = 1
				Return ExecScript(_Screen.cThorDispatcher, lcPrgName, lxP1, lxP2)
		
			Case Atc([Set Option=], lcPrgName) = 1
				Return ExecScript(_Screen.cThorDispatcher, lcPrgName, lxP1, lxP2, lxP3)
		
			Case Atc([Thor Template Code=], lcPrgName) = 1
				Return ExecScript(_Screen.cThorDispatcher, lcPrgName)
		
			Case Atc([Clear HotKeys], lcPrgName) = 1
				Do (lcThorApp) With 'Clear HotKeys'
		
			Case Atc([Toggle Debug Mode], lcPrgName) = 1
				_Screen.lThorDebugMode = not _Screen.lThorDebugMode		
				Set Mark of Bar 6 of Menu_4NU0XBVVF to _Screen.lThorDebugMode
				If _Screen.lThorDebugMode
					Set Asserts on
				EndIf 
		
			Case Atc([Edit=], lcPrgName) = 1
				Return ExecScript(_Screen.cThorDispatcher, lcPrgName)
		
			Case Atc([Link=], lcPrgName) = 1
				Return ExecScript(_Screen.cThorDispatcher, lcPrgName)
		
				* Get ToolInfo for tool
			Case Atc([ToolInfo=], lcPrgName) = 1
				Return ExecScript(_Screen.cThorDispatcher, lcPrgName, lxP1)
		
			Case Atc([DoDefault()], lcPrgName) = 1
				lcPRGName = ''
				llFirst	  = .F.
				For lnI = Program (-1) To 1 Step - 1
					lcSys16 = Sys(16, lnI)
					Do Case
						Case Upper (Getwordnum (lcSys16, 1)) = 'PROCEDURE'
						Case Not llFirst
							llFirst = .T.
						Otherwise
							lcPRGName = JustStem (lcSys16)
							Exit
					Endcase
				Endfor
		
				Return This.ExecuteThorProc (lcPRGName, lcThorFolder, llThorInkey, .T., Pcount(), @lxP1, @lxP2, @lxP3, @lxP4, @lxP5, @lxP6, @lxP7, @lxP8, @lxP9, @lxP10)
		
			Otherwise
				Return This.ExecuteThorProc(lcPRGName, lcThorFolder, llThorInkey, .F., Pcount(), @lxP1, @lxP2, @lxP3, @lxP4, @lxP5, @lxP6, @lxP7, @lxP8, @lxP9, @lxP10)
		
		Endcase
		
		Return
		
		
	ENDPROC

	PROCEDURE executethorproc
		Lparameters lcPRGName, lcThorFolder, llThorInkey, llDoDefault, lnPCount, lxP1, lxP2, lxP3, lxP4, lxP5, lxP6, lxP7, lxP8, lxP9, lxP10, lcFileText
		
		Local lcFullPRGName, lcParams, lnI
		lcFullPRGName = This.GetFullFileName(m.lcPRGName, m.lcThorFolder, m.llDoDefault)
		If Empty(m.lcFullPRGName)
			Return .Null.
		Endif
		
		_Screen.lThorInkey	= _Screen.lThorInkey Or m.llThorInkey
		_Screen.xThorResult	= .T.
		If m.lnPCount < 2
			lcParams = ''
		Else
			lcParams = 'with lxP1'
			For lnI = 2 To m.lnPCount - 1
		*** DH 2018-10-12: as suggested by Toni Koehler, use ALLTRIM(STR()) instead of
		*** TRANSFORM() because with SET POINT TO ',' and SET FIXED ON, TRANSFORM(1)
		*** gives "1,000" which looks like multiple parameters: lcP1,lxP2,000,lxP3,000, etc.
		*		lcParams = m.lcParams + ', lxP' + Transform(m.lnI)
				lcParams = m.lcParams + ', lxP' + alltrim(str(m.lnI))
			Endfor
		Endif
		
		Assert Not _Screen.lThorDebugMode Message 'Debug:     ' + Juststem(m.lcFullPRGName)
		Do(m.lcFullPRGName) &lcParams
		
		_Screen.lThorInkey = _Screen.lThorInkey And Type('llThorInkey') = 'L' And Not m.llThorInkey
		Return _Screen.xThorResult
		
	ENDPROC

	PROCEDURE getfullfilename
		Lparameters lcPRGName, lcThorFolder, llDoDefault
		Local lcFile, lcFullPRGName1, lcFullPRGName2, lcFullPRGName3
		
		If Empty(Justext(m.lcPRGName))
			lcFile = Forceext (m.lcPRGName, 'prg')
		Else
			lcFile = m.lcPRGName
		Endif
		lcFullPRGName1 = Forcepath (m.lcFile, m.lcThorFolder + 'Tools\' + ccMyTools)
		lcFullPRGName2 = Forcepath (m.lcFile, m.lcThorFolder + 'Tools\' + ccProcs)
		lcFullPRGName3 = Forcepath (m.lcFile, m.lcThorFolder + 'Tools\')
		Do Case
			Case File (m.lcFile) And Not m.llDoDefault
				lcFile = Fullpath (m.lcFile)
			Case File (m.lcFullPRGName1) And Not m.llDoDefault
				lcFile = m.lcFullPRGName1
			Case File (m.lcFullPRGName2)
				lcFile = m.lcFullPRGName2
			Case File (m.lcFullPRGName3)
				lcFile = m.lcFullPRGName3
			Otherwise
				lcFile = ''
		Endcase
		Return m.lcFile
		
	ENDPROC

	PROCEDURE Init
		lparameters tcFolder
		local lcFolder
		This.cAppFolder = Addbs(JustPath(JustPath(tcFolder)))
		*** JRN 2011-04-14 : 
		Set Deleted On
		
	ENDPROC

ENDDEFINE

DEFINE CLASS thor_engine AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "thor_ui.h"
	*<DefinedPropArrayMethod>
		*m: addfoldertools
		*m: additemtomenu		&& Adds an item (tool or separator) to a menu
		*m: addmenu		&& Adds a menu to the Thor tables
		*m: addsubmenu		&& Adds a submenu
		*m: addtoolhotkey		&& Adds a hotkey to a tool
		*m: diskfilename
		*m: findfile		&& Finds a file in one of Thor's paths
		*m: findoption
		*m: getitembyposition		&& Returns the ID for an item in the specified menu by its order in the menu
		*m: getkeydesc
		*m: getkeydescriptionfromkeycode
		*m: getkeyvaluefromkeyname
		*m: getmacrodefinitions
		*m: getmenubyname		&& Returns the ID for the menu with the specified name
		*m: getmenuitems		&& Returns a list of items in the specified menu
		*m: getonkeylabeldefinitions
		*m: getoption		&& Returns the value of the specified Thor option
		*m: gettableforalias
		*m: gettooldescription
		*m: gettoolscollection		&& Returns a collection with registered tools
		*m: opentable
		*m: opentables		&& Opens the Thor tables
		*m: packtable
		*m: packtables
		*m: removeitemfrommenu		&& Removes the specified item from the specified menu
		*m: removemenu		&& Removes the specified menu
		*m: removetool
		*m: removetoolhotkey		&& Removes the hot key for the specified tool
		*m: renumbermenuitems		&& Renumbers the items for the specified menu so there are no gaps in the sequence
		*m: renumbermenus		&& Renumbers all menus so there are no gaps in the sequence
		*m: setmenuprompt
		*m: setoption
		*p: cappfolder
		*p: ctablesfolder		&& The folder for the Thor tables
		*p: cthorfolder
		*p: ctoolsfolder		&& The folder for the Thor tools
		*p: cversion		&& The Thor version number
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		cappfolder = .F.
		ctablesfolder = 
		cthorfolder = 
		ctoolsfolder = 
		cversion =          0.4
		Name = "thor_engine"
		Width = 17
		_memberdata = <VFPData>
			<memberdata name="findfile" display="FindFile"/>
			<memberdata name="gettoolscollection" display="GetToolsCollection"/>
			<memberdata name="createthorfolders" display="CreateThorFolders"/>
			<memberdata name="addmenu" display="AddMenu"/>
			<memberdata name="ctablesfolder" display="cTablesFolder"/>
			<memberdata name="addsubmenu" display="AddSubMenu"/>
			<memberdata name="additemtomenu" display="AddItemToMenu"/>
			<memberdata name="getmenubyname" display="GetMenuByName"/>
			<memberdata name="opentables" display="OpenTables"/>
			<memberdata name="removemenu" display="RemoveMenu"/>
			<memberdata name="removeitemfrommenu" display="RemoveItemFromMenu"/>
			<memberdata name="getitembyposition" display="GetItemByPosition"/>
			<memberdata name="renumbermenuitems" display="RenumberMenuItems"/>
			<memberdata name="renumbermenus" display="RenumberMenus"/>
			<memberdata name="ctoolsfolder" display="cToolsFolder"/>
			<memberdata name="addtoolhotkey" display="AddToolHotKey"/>
			<memberdata name="removetoolhotkey" display="RemoveToolHotKey"/>
			<memberdata name="cversion" display="cVersion"/>
			<memberdata name="getoption" display="GetOption"/>
			<memberdata name="getmenuitems" display="GetMenuItems"/>
			<memberdata name="getkeyvaluefromkeyname" display="GetKeyValueFromKeyName"/>
			<memberdata name="packtables" display="PackTables"/>
			<memberdata name="packtable" display="PackTable"/>
			<memberdata name="addfoldertools" display="AddFolderTools"/>
			<memberdata name="gettooldescription" display="GetToolDescription"/>
			<memberdata name="getonkeylabeldefinitions" display="GetOnKeyLabelDefinitions"/>
			<memberdata name="getmacrodefinitions" display="GetMacroDefinitions"/>
			<memberdata name="getkeydescriptionfromkeycode" display="GetKeyDescriptionFromKeyCode"/>
			<memberdata name="getkeydesc" display="GetKeyDesc"/>
			<memberdata name="diskfilename" display="DiskFileName"/>
			<memberdata name="cthorfolder" display="cThorFolder"/>
			<memberdata name="setmenuprompt" display="SetMenuPrompt"/>
			<memberdata name="removetool" display="RemoveTool"/>
			<memberdata name="setoption" display="SetOption"/>
			<memberdata name="findoption" display="FindOption"/>
			<memberdata name="opentable" display="OpenTable"/>
			<memberdata name="gettableforalias" display="GetTableForAlias"/>
			<memberdata name="do" display="Do"/>
			<memberdata name="executethorproc" display="ExecuteThorProc"/>
			<memberdata name="getfullfilename" display="GetFullFileName"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE addfoldertools
		Lparameters toTools, tcFolder, tlPrivateCopy
		
		* Get a list of PRGs in the specified folder.
		
		Local loThorInfo As 'ThorInfo' Of 'Thor_Utils.vcx'
		Local laTools[1], lcCategories, lcCategory, lcTool, lcUpperTool, lnI, lnJ, lnSort, lnTools
		Local loException
		
		lnTools  = Adir (laTools, tcFolder + ccTOOLNAMEPREFIX + '*.prg', '', 1)
		
		* Get the information for each tool and add it to the collection.
		
		For lnI = 1 To lnTools
			lcTool	   = laTools[lnI, 1]
			loThorInfo = Newobject ('ThorInfo', 'Thor_Utils.vcx')
			Try
				Do (tcFolder + lcTool) With loThorInfo
				If Not Empty (loThorInfo.Prompt)
					lcUpperTool = Upper (lcTool)
		
					Do Case
						Case 0 = toTools.GetKey (lcUpperTool)
							lcCategories			= Trim (Evl (loThorInfo.Category, Evl (loThorInfo.Source, '(None)')))
							lnSort					= Evl (loThorInfo.Sort, 9999)
							loThorInfo.PRGName		= lcTool
							loThorInfo.FullFileName	= tcFolder + lcTool
							loThorInfo.PrivateCopy	= Iif(tlPrivateCopy, 1, 0)
		
							For lnJ = 1 To Getwordcount (lcCategories, ccCR)
								lcCategory				= Getwordnum (lcCategories, lnJ, ccCR)
								loThorInfo.InternalSort	= Upper (lcCategory + '|' + Iif (lnSort < 0, ' ', '~') + Str (Abs (lnSort), 5) +  loThorInfo.Prompt)
								loThorInfo.Category		= lcCategory
								toTools.Add (loThorInfo, lcUpperTool + Iif (lnJ = 1, '', Transform (lnJ)))
							Endfor
						Case Not tlPrivateCopy
							toTools.Item[lcUpperTool].PrivateCopy = -1
					Endcase
		
				Endif Not Empty (loThorInfo.Prompt)
			Catch To loException
				*** fail silently
			Endtry
		Next lnI
		
	ENDPROC

	PROCEDURE additemtomenu		&& Adds an item (tool or separator) to a menu
		*==============================================================================
		* Method:			AddItemToMenu
		* Purpose:			Adds an item (tool or separator) to a menu
		* Author:			Doug Hennig
		* Last revision:	03/23/2011
		* Parameters:		tnMenuID   - the ID for the menu this belongs to
		*						(required)
		*					tcPRGName  - the PRG name of the tool (ignored if
		*						tlSeparator is .T.; required if .F.)
		*					tcPrompt   - the prompt for the item (ignored if
		*						tlSeparator is .T.; required if .F.)
		*					tlSeparator - .T. if this is a separator
		*					tnOrder    - the order for the menu (optional: if it
		*						isn't passed, this menu appears at the bottom of the
		*						menu it's in)
		*					tcStatusBarText - the status bar text (optional)
		* Returns:			the ID of the new item
		* Environment in:	see This.OpenTables for requirements
		* Environment out:	MenuTools is positioned to the new record
		*					MenuDefinitions is positioned to the menu the item is added
		*						to
		*==============================================================================
		
		lparameters tnMenuID, ;
			tcPRGName, ;
			tcPrompt, ;
			tlSeparator, ;
			tnOrder, ;
			tcStatusBarText
		local laOrder[1], ;
			lnOrder, ;
			lcPRGName, ;
			lcPrompt
		
		* Open the tables if necessary.
		
		This.OpenTables()
		
		* Ensure we have valid parameters.
		
		do case
			case vartype(tnMenuID) <> 'N' or ;
				not seek(tnMenuID, 'MenuDefinitions', 'ID')
				error 11
			case vartype(tlSeparator) <> 'L'
				error 11
			*!* * Removed 2/28/2012 
			*!* case not tlSeparator and (vartype(tcPRGName) <> 'C' or empty(tcPRGName))
			*!* 	error 11
			*!* * Removed 2/28/2012 
			*!* case not tlSeparator and (vartype(tcPrompt) <> 'C' or empty(tcPrompt))
			*!* 	error 11
			case vartype(tnOrder) <> 'L' and (vartype(tnOrder) <> 'N' or tnOrder < 1)
				error 11
			case not inlist(vartype(tcStatusBarText), 'L', 'C')
				error 11
		endcase
		
		* If an order wasn't specified, get the next SortOrder value to use.
		
		if vartype(tnOrder) <> 'N'
			select max(SortOrder) from MenuTools into array laOrder ;
				where MenuID = tnMenuID
			lnOrder = Nvl(Evl(laOrder[1],0), 0) + 1
		endif vartype(tnOrder) <> 'N'
		
		* Add a record for the menu.
		
		lcPRGName = iif(tlSeparator, '', tcPRGName)
		lcPrompt  = iif(tlSeparator, '\-', tcPrompt)
		insert into MenuTools (MenuID, PRGName, SortOrder, Prompt, Separator, StatusBar) ;
			values (tnMenuID, lcPRGName, lnOrder, lcPrompt, tlSeparator, evl(tcStatusBarText, ''))
		return MenuTools.ID
		
	ENDPROC

	PROCEDURE addmenu		&& Adds a menu to the Thor tables
		*==============================================================================
		* Method:			AddMenu
		* Purpose:			Adds a menu to the Thor tables
		* Author:			Doug Hennig
		* Last revision:	04/25/2011
		* Parameters:		tcPrompt   - the prompt for the menu (required)
		*					tlTopLevel - .T. for a top-level menu (if both tlTopLevel
		*						and tlPopup are .F., this is a submenu so tnParentID
		*						is required)
		*					tlPopup    - .T. for a popup menu
		*					tnOrder    - the order for the menu (optional: if it
		*						isn't passed, this menu appears at the bottom of the
		*						menu it's in for a submenu or at the right end of the
		*						menu bar for a top-level menu; not used if only a popup
		*						menu ie. tlTopLevel is .F.)
		*					tcStatusBarText - the status bar text (optional)
		*					tnKeyCode       - the key code for the hot key (optional;
		*						if passed, same value as passed to TextBox.KeyPress)
		*					tnShiftCtrlAlt  - the status of the modifier keys for the
		*						hot key (optional; if passed, same value as passed to
		*						TextBox.KeyPress)
		*					tcPopupName     - the name for the popup menu (optional: if
		*						it isn't passed, SYS(2015) is used)
		* Returns:			the ID of the new menu or 0 if it wasn't added
		* Environment in:	see This.OpenTables for requirements
		* Environment out:	a record was added to MenuDefinitionsm, which is positioned
		*						to the new record
		*					a record may have been added to HotKeyDefinitions and it
		*						may be positioned to the record for the hotkey
		*==============================================================================
		
		lparameters tcPrompt, ;
			tlTopLevel, ;
			tlPopup, ;
			tnOrder, ;
			tcStatusBarText, ;
			tnKeyCode, ;
			tnShiftCtrlAlt, ;
			tcPopupName
		local lcPopupName, ;
			lnOrder, ;
			laOrder[1], ;
			lnHotKeyID, ;
			loKey, ;
			lnSelect, ;
			lcDescrip, ;
			lcFkyValue, ;
			lnID
		
		* Open the tables if necessary.
		
		This.OpenTables()
		
		* Ensure we have valid parameters.
		
		do case
			case vartype(tcPrompt) <> 'C' or empty(tcPrompt)
				error 11
			case vartype(tlTopLevel) <> 'L' or vartype(tlPopup) <> 'L'
				error 11
			*!* * Removed 9/9/2011 
			*!* case not tlTopLevel and not tlPopup
			*!* 	error 11
			case vartype(tnOrder) <> 'L' and (vartype(tnOrder) <> 'N' or tnOrder < 1)
				error 11
			case not inlist(vartype(tcStatusBarText), 'L', 'C')
				error 11
			case vartype(tnKeyCode) <> 'L' and (vartype(tnKeyCode) <> 'N' or ;
				not seek(tnKeyCode, 'HotKeys', 'KeyCode'))
				error 11
			case vartype(tnShiftCtrlAlt) <> 'L' and (vartype(tnShiftCtrlAlt) <> 'N' or ;
				tnShiftCtrlAlt < 0)
				error 11
			case vartype(tcPopupName) <> 'L' and (vartype(tcPopupName) <> 'C' or ;
				empty(tcPopupName))
				error 11
		endcase
		
		* Assign the popup name.
		
		lcPopupName = iif(vartype(tcPopupName) = 'C', tcPopupName, sys(2015))
		
		* If we're adding the menu to the top level and an order wasn't specified, get
		* the next SortOrder value to use.
		
		do case
			case not tlTopLevel
				lnOrder = 0
			case vartype(tnOrder) <> 'N'
				select max(SortOrder) from MenuDefinitions into array laOrder ;
					where TopLevel
				lnOrder = Nvl(Evl(laOrder[1],0), 0) + 1
			otherwise
				lnOrder = tnOrder
		endcase
		
		* If a keycode was specified, see if it exists and if it's already used.
		
		lnHotKeyID = 0
		if vartype(tnKeyCode) = 'N' and vartype(tnShiftCtrlAlt) = 'N'
			loKey = newobject('HotKey', 'Thor_Utils.vcx')
			loKey.nScanCode = HotKeys.ScanCode
				&& we use the scan code not the key code
			loKey.lShift    = bittest(tnShiftCtrlAlt, 0)
			loKey.lCtrl     = bittest(tnShiftCtrlAlt, 1)
			loKey.lAlt      = bittest(tnShiftCtrlAlt, 2)
			lnSelect        = select()
			select HotKeyDefinitions
			locate for nKeyCode = HotKeys.ScanCode and nShifts = tnShiftCtrlAlt
			do case
				case not loKey.IsValid()
		*** need to handle this. Use ERROR to throw error?
		***			This.cErrorMessage = 'already used'
					lnHotKeyID = -1
				case not found()
					lcDescrip  = loKey.GetHotKeyDescription()
					lcFkyValue = loKey.GetKeyCode()
					insert into HotKeyDefinitions (nKeyCode, nShifts, Descript, FkyValue) ;
						values (HotKeys.ScanCode, tnShiftCtrlAlt, lcDescrip, lcFkyValue)
					lnHotKeyID = ID
				case seek(HotKeyDefinitions.ID, 'MenuDefinitions', 'HotKeyID')
		*** need to handle this. Use ERROR to throw error?
		***			This.cErrorMessage = 'already used'
					lnHotKeyID = -1
				otherwise
					lnHotKeyID = ID
			endcase
			select (lnSelect)
		*!* * Removed 9/9/2011 
		*!* *** JRN 2011-04-14 : if no hot keys, can't be a pop-up menu
		*!* *   this allows creation of sub-menus (neither top-level nor popup)
		*!* Else
		*!* 	tlPopup = .F.
		endif vartype(tnKeyCode) = 'N' ...
		
		* Add a record for the menu.
		
		if lnHotKeyID >= 0
			insert into MenuDefinitions ;
				(Prompt, TopLevel, Popup, PopupName, SortOrder, HotKeyID, StatusBar) ;
				values (tcPrompt, tlTopLevel, tlPopup, lcPopupName, lnOrder, lnHotKeyID, ;
					evl(tcStatusBarText, ''))
			lnID = MenuDefinitions.ID
		else
			lnID = 0
		endif lnHotKeyID >= 0
		return lnID
		
	ENDPROC

	PROCEDURE addsubmenu		&& Adds a submenu
		*==============================================================================
		* Method:			AddSubMenu
		* Purpose:			Adds a submenu
		* Author:			Doug Hennig
		* Last revision:	04/16/2011
		* Parameters:		tnParentID - the ID for the menu this is a submenu of
		*						(required)
		*					tnMenuID   - the ID of an existing menu if we're adding
		*						it as a submenu (optional: if it isn't passed, a new
		*						menu is created)
		*					tcPrompt   - the prompt for the menu (required if tnMenuID
		*						is not passed)
		*					tnOrder    - the order for the menu (optional: if it
		*						isn't passed, this menu appears at the bottom of the
		*						menu it's in)
		*					tcStatusBarText - the status bar text (optional)
		* Returns:			the ID of the new menu
		* Environment in:	see This.OpenTables for requirements
		* Environment out:	MenuDefinitions and MenuTools are positioned to the new
		*						records
		*==============================================================================
		
		lparameters tnParentID, ;
			tnMenuID, ;
			tcPrompt, ;
			tnOrder, ;
			tcStatusBarText
		local lcPopupName, ;
			laOrder[1], ;
			lnOrder, ;
			lnMenuID, ;
			lcPrompt
		
		* Open the tables if necessary.
		
		This.OpenTables()
		
		* Ensure we have valid parameters.
		
		do case
			case vartype(tnParentID) <> 'N' and ;
				not seek(tnParentID, 'MenuDefinitions', 'ID')
				error 11
			case (vartype(tnMenuID) = 'N' and ;
				not seek(tnMenuID, 'MenuDefinitions', 'ID'))
				error 11
			case vartype(tnMenuID) <> 'N' and vartype(tnMenuID) <> 'L'
				error 11
			case vartype(tnMenuID) = 'L' and (vartype(tcPrompt) <> 'C' or ;
				empty(tcPrompt))
				error 11
			case vartype(tnOrder) <> 'L' and (vartype(tnOrder) <> 'N' or tnOrder < 1)
				error 11
			case not inlist(vartype(tcStatusBarText), 'L', 'C')
				error 11
		endcase
		
		* Assign the popup name.
		
		lcPopupName = sys(2015)
		
		* If an order wasn't specified, get the next SortOrder value to use.
		
		if vartype(tnOrder) <> 'N'
			select max(SortOrder) from MenuTools into array laOrder ;
				where MenuID = tnParentID
			lnOrder = Nvl(Evl(laOrder[1],0), 0)  + 1
		endif vartype(tnOrder) <> 'N'
		
		* Add a record for the menu.
		
		if vartype(tnMenuID) = 'N'
			lnMenuID = tnMenuID
			lcPrompt = Evl( tcPrompt, MenuDefinitions.Prompt)
		else
			insert into MenuDefinitions ;
				(Prompt, PopupName, StatusBar) ;
				values (tcPrompt, lcPopupName, evl(tcStatusBarText, ''))
			lnMenuID = MenuDefinitions.ID
			lcPrompt = tcPrompt
		endif vartype(tnMenuID) = 'N'
		insert into MenuTools (MenuID, SubMenuID, SortOrder, Prompt) ;
			values (tnParentID, lnMenuID, lnOrder, lcPrompt)
		return MenuDefinitions.ID
		
	ENDPROC

	PROCEDURE addtoolhotkey		&& Adds a hotkey to a tool
		*==============================================================================
		* Method:			AddToolHotKey
		* Purpose:			Adds a hotkey to a tool
		* Author:			Doug Hennig
		* Last revision:	04/25/2011
		* Parameters:		tcPRGName      - the PRG name of the tool (required)
		*					tnKeyCode      - the key code for the hot key (optional;
		*						if passed, same value as passed to TextBox.KeyPress;
		*						if not passed, any existing hotkey assignment is
		*						cleared)
		*					tnShiftCtrlAlt - the status of the modifier keys for the
		*						hot key (optional; if passed, same value as passed to
		*						TextBox.KeyPress; if not passed, any existing hotkey
		*						assignment is cleared)
		*                   tlAddOnly -- if .T., existing hot key for the tool will not be replaced
		* Returns:			none
		* Environment in:	none
		* Environment out:	a record may have been created in ToolHotKeyAssignments
		*					ToolHotKeyAssignments.HotKeyID is set to the specified
		*						hotkey (if it's valid) or 0 if the keycode isn't
		*						specified
		*==============================================================================
		
		lparameters tcPRGName, ;
			tnKeyCode, ;
			tnShiftCtrlAlt, ;
			tlAddOnly
		
		* Open the tables if necessary.
		
		This.OpenTables()
		
		* Ensure we have valid parameters.
		
		do case
			case vartype(tcPRGName) <> 'C' or empty(tcPRGName)
				error 11
			case vartype(tnKeyCode) <> 'L' and (vartype(tnKeyCode) <> 'N' or ;
				not seek(tnKeyCode, 'HotKeys', 'KeyCode'))
				error 11
			case vartype(tnShiftCtrlAlt) <> 'L' and (vartype(tnShiftCtrlAlt) <> 'N' or ;
				tnShiftCtrlAlt < 0)
				error 11
		endcase
		
		* If a keycode was specified, see if it exists and if it's already used.
		
		lnHotKeyID = 0
		if vartype(tnKeyCode) = 'N' and vartype(tnShiftCtrlAlt) = 'N'
			loKey = newobject('HotKey', 'Thor_Utils.vcx')
			loKey.nScanCode = HotKeys.ScanCode
				&& we use the scan code not the key code
			loKey.lShift    = bittest(tnShiftCtrlAlt, 0)
			loKey.lCtrl     = bittest(tnShiftCtrlAlt, 1)
			loKey.lAlt      = bittest(tnShiftCtrlAlt, 2)
			lnSelect        = select()
			select HotKeyDefinitions
			locate for nKeyCode = HotKeys.ScanCode and nShifts = tnShiftCtrlAlt
			do case
				case not loKey.IsValid()
		*** need to handle this. Use ERROR to throw error?
		***			This.cErrorMessage = 'already used'
					lnHotKeyID = -1
				case not found()
					lcDescrip  = loKey.GetHotKeyDescription()
					lcFkyValue = loKey.GetKeyCode()
					insert into HotKeyDefinitions (nKeyCode, nShifts, Descript, FkyValue) ;
						values (HotKeys.ScanCode, tnShiftCtrlAlt, lcDescrip, lcFkyValue)
					lnHotKeyID = ID
				case seek(HotKeyDefinitions.ID, 'MenuDefinitions', 'HotKeyID')
		*** need to handle this. Use ERROR to throw error?
		***			This.cErrorMessage = 'already used'
					lnHotKeyID = -1
				otherwise
					lnHotKeyID = ID
			endcase
			select (lnSelect)
		endif vartype(tnKeyCode) = 'N' ...
		
		* Create a record in ToolHotKeyAssignments if necessary.
		
		*** JRN 2011-04-14 : exit if hot key already defined AND tlAddOnly = .T.
		Do case
			case not seek(upper(tcPRGName), 'ToolHotKeyAssignments', 'PRGName')
				insert into ToolHotKeyAssignments (PRGName) values (tcPRGName)
		*** JRN 2011-04-14 : if this tool already has a hot key
		*                    and tlHotKey is .T., nothing to do
			Case tlAddOnly
				Return -1
		EndCase 
		
		* Assign the hotkey.
		
		replace HotKeyID with lnHotKeyID in ToolHotKeyAssignments
		
	ENDPROC

	PROCEDURE diskfilename
		Lparameters lcFileName
		
		#Define MAX_PATH 260
		
		Local lnFindFileData, lnHandle, lcXXX
		Declare Integer FindFirstFile In win32api String @, String @
		Declare Integer FindNextFile In win32api Integer, String @
		Declare Integer FindClose In win32api Integer
		
		Do Case
			Case ( Right (lcFileName, 1) == '\' )
				Return Addbs (This.DiskFileName (Left (lcFileName, Len (lcFileName) - 1)))
		
			Case Empty (lcFileName)
				Return ''
		
			Case ( Len (lcFileName) == 2 ) And ( Right (lcFileName, 1) == ':' )
				Return Upper (lcFileName)	&& win2k gives curdir() for C:
		Endcase
		
		lnFindFileData = Space(4 + 8 + 8 + 8 + 4 + 4 + 4 + 4 + MAX_PATH + 14)
		lnHandle		 = FindFirstFile (@lcFileName, @lnFindFileData)
		
		If ( lnHandle < 0 )
			If ( Not Empty (Justfname (lcFileName)) )
				lcXXX = Justfname (lcFileName)
			Else
				lcXXX = lcFileName
			Endif
		Else
			= FindClose (lnHandle)
			lcXXX	= Substr (lnFindFileData, 45, MAX_PATH)
			lcXXX	= Left (lcXXX, At (Chr(0), lcXXX) - 1)
		Endif
		
		
		Do Case
			Case Empty (Justpath (lcFileName))
				Return lcXXX
			Case ( Justpath (lcFileName) == '\' ) And (Left (lcFileName, 2) == '\\')	&& unc
				Return '\\' + lcXXX
			Otherwise
				Return Addbs (This.DiskFileName (Justpath (lcFileName))) + lcXXX
		Endcase
		
		Return
		
	ENDPROC

	PROCEDURE findfile		&& Finds a file in one of Thor's paths
		*==============================================================================
		* Method:			FindFile
		* Purpose:			Finds the file in one of the Thor paths
		* Author:			Doug Hennig
		* Last revision:	6/21/2011 JRN
		* Parameters:		tcFile - the file to find
		* Returns:			the file with the path it was found in or blank if it
		*						wasn't found
		* Environment in:	This.cToolsFolder contains the default folder for tools
		* Environment out:	none
		*==============================================================================
		
		lparameters tcFile
		local lcFile
		do case
			case file(tcFile)
				lcFile = tcFile
			case file(This.cToolsFolder + ccMyTools + '\' + tcFile)
				lcFile = This.cToolsFolder + ccMyTools + '\' + tcFile
			case file(This.cToolsFolder + tcFile)
				lcFile = This.cToolsFolder + tcFile
			otherwise
				lcFile = ''
		endcase
		return lcFile
		
	ENDPROC

	PROCEDURE findoption
		*==============================================================================
		* Method:			GetOption
		* Purpose:			Finds the specified Thor option
		* Author:			Jim Nelson
		* Last revision:	04/09/2011
		* Parameters:		tcKey - the key for the option
		*					tcTool - name of the tool this applies to (internally, may be left off)
		* Returns:			.T. if found
		* Environment in:	Thor.DBF is open
		* Environment out:	Thor.DBF is positioned to the record for the option or EOF
		*						if it wasn't found
		*==============================================================================
		
		Lparameters tcKey, tcTool
		Local lnSelect, luReturn
		
		* Open the tables if necessary.
		
		This.OpenTables()
		
		* Find the key in Thor and convert the value to the desired data type.
		
		lnSelect = Select()
		Select Thor
		Locate For Upper (Key) = Padr (Upper (tcKey), 30)  ;
			and Upper (Tool) = Padr (Upper (Evl (tcTool, 'Thor')), 60)
		
		luReturn = Found()
		
		Select (lnSelect)
		Return luReturn
		
	ENDPROC

	PROCEDURE getitembyposition		&& Returns the ID for an item in the specified menu by its order in the menu
		*==============================================================================
		* Method:			GetItemByPosition
		* Purpose:			Returns the ID for an item in the specified menu by its
		*						order in the menu
		* Author:			Doug Hennig
		* Last revision:	03/23/2011
		* Parameters:		tnMenuID - the menu the tool belongs to (required)
		*					tnOrder  - the order for the item (required)
		* Returns:			the ID of the tool's record in MenuTools or 0 of not found
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		lparameters tnMenuID, ;
			tcPRGName
		local lnSelect, ;
			lnID
		
		* Open the tables if necessary.
		
		This.OpenTables()
		
		* Ensure we have valid parameters.
		
		do case
			case vartype(tnMenuID) <> 'N' or ;
				not seek(tnMenuID, 'MenuDefinitions', 'ID')
				error 11
			case vartype(tnOrder) <> 'N' or tnOrder <= 0
				error 11
		endcase
		
		* Find the item.
		
		lnSelect = select()
		select MenuTools
		locate for MenuID = tnMenuID and SortOrder = tnOrder
		lnID = ID
		select (lnSelect)
		return lnID
		
	ENDPROC

	PROCEDURE getkeydesc
		Lparameters lnShift
		
		Return IIf(0 # Bitand(lnShift, cnSHIFT), ccSHIFT, '');
			+ IIf(0 # Bitand(lnShift, cnCTRL), ccCTRL,  '') ;
			+ IIf(0 # Bitand(lnShift, cnALT), ccALT, '') ;
			+ Trim(HotKeys.Key)
		
	ENDPROC

	PROCEDURE getkeydescriptionfromkeycode
		*==============================================================================
		* Method:			GetKeyDescriptionKeyCode
		* Purpose:			Returns the description given the 2-byte macro key code
		* Author:			Jim Nelson
		* Last revision:	05/27/2011
		* Parameters:		the 2-byte macro key code for the specified key or .NULL.
		*						if we can't create a macro key code
		* Returns:          the description for the key
		*==============================================================================
		
		Lparameters lcKeyCode, llBrackets
		
		Local lcLeftBracket, lcRightBracket, lnAsc1, lnAsc2
		
		lnAsc1 = Asc (Substr (lcKeyCode, 1, 1 ))
		lnAsc2 = Asc (Substr (lcKeyCode, 2, 1 ))
		
		lcLeftBracket  = IIf (llBrackets, '{', '')
		lcRightBracket = IIf (llBrackets, '}', '')
		
		Select HotKeys
		
		Do Case
		
			Case lnAsc2 = 1
		
				Locate For HotKeys.ShCode = lnAsc1
				If Found()
					Return lcLeftBracket + This.GetKeyDesc (cnNO_MODIFIER) + lcRightBracket
				Endif
		
				Return '??'
		
			Case Not Inlist ( lnAsc2, 0, 16)
		
				Locate For HotKeys.BareCode = lnAsc1 And HotKeys.BareKey = lnAsc2
				If Found()
					Return lcLeftBracket + This.GetKeyDesc (cnNO_MODIFIER) + lcRightBracket
				Endif
		
				Locate For HotKeys.ShCode = lnAsc1 And HotKeys.ShKey  = lnAsc2
				If Found()
					Return lcLeftBracket + This.GetKeyDesc (cnSHIFT) + lcRightBracket
				Endif
		
				Locate For HotKeys.CtCode = lnAsc1 And HotKeys.CtKey = lnAsc2
				If Found()
					Return lcLeftBracket + This.GetKeyDesc (cnCTRL) + lcRightBracket
				Endif
		
				Locate For HotKeys.AltCode = lnAsc1 And HotKeys.AltKey  = lnAsc2
				If Found()
					Return lcLeftBracket + This.GetKeyDesc (cnALT) + lcRightBracket
				Endif
		
				Locate For HotKeys.ShCtCode = lnAsc1 And HotKeys.ShCtKey = lnAsc2
				If Found()
					Return lcLeftBracket + This.GetKeyDesc (cnSHIFT + cnCTRL) + lcRightBracket
				Endif
		
				Locate For HotKeys.AltCode = lnAsc1 And HotKeys.ShAltKey = lnAsc2
				If Found()
					Return lcLeftBracket + This.GetKeyDesc (cnSHIFT + cnALT) + lcRightBracket
				Endif
		
				Locate For HotKeys.AltCode = lnAsc1 And HotKeys.CtAltKey  = lnAsc2
				If Found()
					Return lcLeftBracket + This.GetKeyDesc (cnCTRL + cnALT) + lcRightBracket
				Endif
		
				Locate For HotKeys.AltCode = lnAsc1 And HotKeys.ShCtAltKey  = lnAsc2
				If Found()
					Return lcLeftBracket + This.GetKeyDesc (cnSHIFT + cnCTRL + cnALT) + lcRightBracket
				Endif
		
				Return '??'
		
			Case lnAsc1 = 8
				Return '{BACKSPACE}'
		
			Case lnAsc1 = 9
				Return '{TAB}'
		
			Case lnAsc1 = 13
				Return '{ENTER}'
		
			Otherwise
				Return Left (lcKeyCode, 1)
		
		Endcase
	ENDPROC

	PROCEDURE getkeyvaluefromkeyname
		*==============================================================================
		* Method:			GetKeyValueFromKeyName
		* Purpose:			Get internal representation of keystroke
		* Author:			Jim Nelson
		* Last revision:	04/23/2011
		* Parameters:		tcKeyName - key name (such as 'Alt-F12')
		*                   tlKeyCodes
		* Returns:			if tlKeyCodes = .F. -- two-byte internal representation, if valid, else empty
		*					if tlKeyCodes = .T. -- object, properties 'KeyCode' and 'nShifts'
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		Lparameters tcKeyName, tlKeyCodes
		
		Local loKey As 'HotKey' Of 'Thor_Utils.vcx'
		Local loResult As 'Empty'
		Local lcFkyValue, lcName, llAlt, llCtrl, llShift, lnKeyCode, lnScanCode, lnSelect
		* Open the tables if necessary.
		
		This.OpenTables()
		
		* Ensure we have valid parameters.
		
		If Vartype (tcKeyName) # 'C' Or Empty (tcKeyName)
			Error 11
		Endif
		
		llShift	= 'SHIFT' $ Upper (tcKeyName)
		llCtrl	= 'CTRL' $ Upper (tcKeyName)
		llAlt	= 'ALT' $ Upper (tcKeyName)
		
		* find the hotkey
		lnSelect = Select()
		Select HotKeys
		lcName = Padr (Upper (Substr (tcKeyName, Max (Rat ('+', tcKeyName), Rat ('-', tcKeyName)) + 1)), 10)
		Locate For Key = lcName
		If Not Found()
			Return ''
		Endif
		
		lnScanCode = HotKeys.ScanCode
		*** DH 04/23/2011: only need keycode
		*Do case
		*	Case llShift
		*		lnKeyCode = HotKeys.ShCode
		*	Case llCtrl
		*		lnKeyCode = HotKeys.CtCode
		*	Case llAlt
		*		lnKeyCode = HotKeys.AltCode
		*	Otherwise
				lnKeyCode = HotKeys.KeyCode
		*EndCase
		
		Select (lnSelect)
		
		* and the result
		If Empty(tlKeyCodes)
			loKey			= Newobject ('HotKey', 'Thor_Utils.vcx')
		
			loKey.nScanCode	= lnScanCode
			loKey.lShift	= llShift
			loKey.lCtrl		= llCtrl
			loKey.lAlt		= llAlt
		
			If loKey.IsValid()
				lcFkyValue = loKey.GetKeyCode()
				Return lcFkyValue
			Else
				Return ''
			EndIf
		Else 
			loResult = CreateObject('Empty')
			AddProperty(loResult, 'KeyCode', lnKeyCode)
			AddProperty(loResult, 'nShifts', IIF(llShift, 1, 0) + IIF(llCtrl, 2, 0) + IIF(llAlt, 4, 0)) 
			Return loResult	
		endif
	ENDPROC

	PROCEDURE getmacrodefinitions
		* Returns collection of all macros (including Thor macros)
		
		Local loHotKeysCollection As 'Collection'
		Local loMacro As 'Empty'
		Local lcDefinition, lcFKYFile, lcFKYFileName, lcKey, lcKeys, lcKeystrokes, lcMacro, lcMacroName
		Local lnCount, lnI, lnJ, lnLength, lnNextByte, lnTotalLength
		
		lcFKYFileName = Addbs (Sys(2023)) + Forceext (Sys(2015), 'FKY')
		Erase (lcFKYFileName)
		
		Save Macros To (lcFKYFileName)
		lcFKYFile = Filetostr (lcFKYFileName)
		Erase (lcFKYFileName)
		
		lnCount = (256 * Asc (Substr (lcFKYFile, 18))) + Asc (Substr (lcFKYFile, 17))
		
		loHotKeysCollection	= Createobject ('Collection')
		lnNextByte			= 19
		For lnI = 1 To lnCount
			lnLength	  = (256 * Asc (Substr (lcFKYFile, lnNextByte + 21))) + Asc (Substr (lcFKYFile, lnNextByte + 20))
			lnTotalLength = 24 + (2 * lnLength)
			lcMacro		  = Substr (lcFKYFile, lnNextByte, lnTotalLength)
			lnNextByte	  = lnNextByte + lnTotalLength
		
			lcMacroName	 = Trim (Strtran (Left (lcMacro, 20), Chr(0), ''))
			lcDefinition = This.GetKeyDescriptionFromKeyCode (Substr (lcMacro, 23, 2))
		
			lcKeystrokes = Substr (lcMacro, 25)
			lcKeys		 = ''
			For lnJ = 1 To Len (lcKeystrokes) Step 2
				lcKey  = Substr (lcKeystrokes, lnJ, 2)
				lcKeys = lcKeys + This.GetKeyDescriptionFromKeyCode (lcKey, .T.)
			Endfor
		
			loMacro = Createobject ('Empty')
			AddProperty (loMacro, 'FKYtext', lcMacro)
			AddProperty (loMacro, 'Keystrokes', lcKeys)
			AddProperty (loMacro, 'Name', lcMacroName)
			AddProperty (loMacro, 'Definition', lcDefinition)
			loHotKeysCollection.Add (loMacro)
		
		Endfor && lnI = 1 to lnCount
		
		Return loHotKeysCollection
		
		
		
		
	ENDPROC

	PROCEDURE getmenubyname		&& Returns the ID for the menu with the specified name
		*==============================================================================
		* Method:			GetMenuByName
		* Purpose:			Returns the ID for the menu with the specified name
		* Author:			Doug Hennig
		* Last revision:	03/23/2011
		* Parameters:		tcPopupName - the name of the popup for the menu to find
		*						(required)
		* Returns:			the ID of the menu if found and 0 if not
		* Environment in:	see This.OpenTables for requirements
		* Environment out:	MenuDefinitions is positioned to the record with the name
		*						if found and EOF if not
		*==============================================================================
		
		lparameters tcPopupName
		local lnSelect
		
		* Open the tables if necessary.
		
		This.OpenTables()
		
		* Ensure we have valid parameters.
		
		if vartype(tcPopupName) <> 'C' or empty(tcPopupName)
			error 11
		endif vartype(tcPopupName) <> 'C' ...
		
		* Try to find the menu by name.
		
		lnSelect = select()
		select MenuDefinitions
		locate for trim(upper(PopupName)) == upper(tcPopupName)
		lnID = ID
		select (lnSelect)
		return lnID
		
	ENDPROC

	PROCEDURE getmenuitems		&& Returns a list of items in the specified menu
		*==============================================================================
		* Method:			GetMenuItems
		* Purpose:			Returns a list of items in the specified menu
		* Author:			Doug Hennig
		* Last revision:	04/13/2011
		* Parameters:		tnMenuID - the ID for the menu (required)
		*					taItems  - an array to three fields of the items for the
		*						menu passed by reference (required):
		*                       ID, PRGName, Prompt
		* Returns:			the number of items in the array
		* Environment in:	none
		* Environment out:	the passed array is filled with items for the menu
		*==============================================================================
		
		lparameters tnMenuID, ;
			taItems
		
		* Open the tables if necessary.
		
		This.OpenTables()
		
		* Ensure we have valid parameters.
		
		do case
			case vartype(tnMenuID) <> 'N' or ;
				not seek(tnMenuID, 'MenuDefinitions', 'ID')
				error 11
			case type('taItems', 1) <> 'A'
				error 11
		endcase
		
		* Fill the array with the items for the menu and return the count.
		
		*** JRN 2011-04-13 : added two more fields, plus sortorder
		select ID, PRGName, Prompt from MenuTools where MenuID = tnMenuID order by sortorder into array taItems
		*** JRN 2011-04-13 
		
		return _tally
		
	ENDPROC

	PROCEDURE getonkeylabeldefinitions
		Local loKey As 'Empty'
		Local loKeyCollection As 'Collection'
		Local laKeys[1], lcExec, lcKey, lcKeyText, lcKeys, lcStr, lcTempFile, lnCount, lnI
		lcTempFile = Addbs (Sys(2023)) + Sys(2015) + '.txt'
		
		*** We need to use a temporary file for this
		Set Console Off
		Set Alternate To (lcTempFile)
		Set Alternate On
		
		*** Dump the memory
		List Status
		
		Set Alternate Off
		Set Alternate To
		Set Console On
		
		lcStr = Filetostr (lcTempFile)
		Delete File (lcTempFile)
		
		****************************************************************
		
		lcStr = Chrtran (lcStr, ccLF, '')
		
		lcKeys			= Strextract (lcStr,  'ON KEY LABEL', 'TEXTMERGE OPTIONS', 1, 1)
		lnCount			= Alines (laKeys, lcKeys)
		loKeyCollection	= Createobject ('Collection')
		For lnI = 2 To lnCount
			lcKeyText = laKeys (lnI)
			lcKey	  = Getwordnum (lcKeyText, 1)
			If Not Empty(lcKey)
				lcExec	  = On('Key', lcKey)
				If Not Empty(lcExec)
					lcKey = Strtran(lcKey, 'SHIFT+', ccSHIFT)
					lcKey = Strtran(lcKey, 'CTRL+', ccCTRL)
					lcKey = Strtran(lcKey, 'ALT+', ccALT)
		
					loKey = Createobject ('Empty')
					AddProperty (loKey, 'Key', lcKey)
					AddProperty (loKey, 'Definition', lcExec)
					loKeyCollection.Add (loKey)
				Endif
			Endif
		Endfor && lnI = 2 to lnCount
		
		Return loKeyCollection
		
	ENDPROC

	PROCEDURE getoption		&& Returns the value of the specified Thor option
		*==============================================================================
		* Method:			GetOption
		* Purpose:			Returns the value of the specified Thor option
		* Author:			Doug Hennig
		* Last revision:	04/09/2011
		* Parameters:		tcKey - the key for the option
		*					tcTool - name of the tool this applies to (internally, may be left off)
		* Returns:			the value of the option or NULL if it wasn't found
		* Environment in:	Thor.DBF is open
		* Environment out:	Thor.DBF is positioned to the record for the option or EOF
		*						if it wasn't found
		*==============================================================================
		
		Lparameters tcKey, tcTool
		Local lnSelect, luReturn
		
		* Open the tables if necessary.
		
		This.OpenTables()
		
		* Find the key in Thor and convert the value to the desired data type.
		
		lnSelect = Select()
		Select Thor
		Locate For Upper (Key) = Padr (Upper (tcKey), 30)  ;
			and Upper (Tool) = Padr (Upper (Evl (tcTool, 'Thor')), 60)
		Do Case
			Case Not Found()
				luReturn = .Null.
			Case Type = 'C'
				luReturn = Value
			Case Type = 'N'
				luReturn = Val (Value)
			Case Type = 'D'
				luReturn = Val (Value) + Date(1899, 12, 30)
			Case Type = 'L'
				luReturn = Value = 'Y'
			Otherwise
				luReturn = .Null.
		Endcase
		Select (lnSelect)
		Return luReturn
		
	ENDPROC

	PROCEDURE gettableforalias
		Lparameters lcAlias
		
		#Define PLACEHOLDER '<*>'
		Local lcName, lcWildCardValue, lnStarPosition
		If Seek(Upper(Padr(lcAlias, 40)), 'TableAliases', 'Alias')
			Return Alltrim(TableAliases.Table)
		Else
			Select TableAliases
			Locate For Like(Upper(Alltrim(Alias)), Upper(Alltrim(lcAlias)))
			If Found()
				lnStarPosition	= At('*', Alias)
				lcWildCardValue	= Substr(lcAlias, lnStarPosition, Len(Alltrim(lcAlias)) - Len(Alltrim(Alias)) + 1)
				lcName			= Alltrim(Table)
				If Empty(lcName)
					Return lcWildCardValue
				Else
					Return Strtran(lcName, PLACEHOLDER, lcWildCardValue)
				Endif
			Else
				Return .F.
			Endif
		Endif
		
	ENDPROC

	PROCEDURE gettooldescription
		Lparameters loTool
		
		Local lcFolder, lcToolFolder, lcValue
		Local cValue
		
		lcValue = ccPROGRAM + ': ' + loTool.PRGName
		If Not Empty (loTool.Source)
			lcValue = lcValue + ccCR + ccSource + ': ' + loTool.Source
		Endif
		
		lcFolder = Justpath (loTool.FullFileName)
		
		lcToolFolder = Addbs (Justpath (This.cToolsFolder))
		Do Case
			Case Upper(Addbs(lcFolder)) == Upper (lcToolFolder)
		
			Case Upper (lcFolder) = Upper (lcToolFolder)
				lcValue = lcValue + ccCR + ccCR + ccFOLDERNAME + ': ' + Substr (This.DiskFileName (lcFolder), Len (lcToolFolder) + 1)
			Otherwise 
				lcValue = lcValue + ccCR + ccCR + ccFOLDERNAME + ': ' + This.DiskFileName (lcFolder)
		Endcase
		
		lcValue = lcValue + ccCR + ccCR + ccDESCRIPTION + ': ' + loTool.Description
		
		If Not Empty (loTool.Author)
			lcValue = lcValue + ccCR + ccCR + ccAUTHOR + ': ' + loTool.Author
		Endif
		
		If Not Empty (loTool.Version)
			lcValue = lcValue + ccCR + ccCR + ccVERSION + ': ' + loTool.Version
		Endif
		
		Return lcValue
		
	ENDPROC

	PROCEDURE gettoolscollection		&& Returns a collection with registered tools
		*==============================================================================
		* Method:			GetToolsCollection
		* Purpose:			Returns a collection with registered tools
		* Author:			Doug Hennig
		* Last revision:	03/24/2011
		* Parameters:		tcFolder - the folder to look in for Thor_Tool PRG files
		*					toTools  - a collection (optional; if it isn't passed, a
		*						new collection is created)
		* Returns:			a collection of ThorInfo objects
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		Lparameters tcFolder,		;
			toTools
		
		Local laFolders[1], lnCount, lnI, loTools
		
		* If we weren't passed one, create a collection to hold tool information.
		
		If Vartype (toTools) = 'O'
			loTools = toTools
		Else
			loTools = Createobject ('Collection')
		Endif Vartype (toTools) = 'O'
		
		*** JRN 2011-05-22 : all tools in current folder
		If Atc(tcFolder, Addbs(Curdir())) = 0
			This.AddFolderTools (loTools, Addbs(Curdir()), .T.)
		Endif
		
		*** JRN 2011-05-04 : find all tools in path
		lnCount = Alines (laFolders, Set ('Path'), .T., ';', ',')
		For lnI = 1 To lnCount
			If Not Empty (laFolders (lnI))
				This.AddFolderTools (loTools, Addbs(laFolders (lnI)), .T.)
			Endif
		Endfor
		This.AddFolderTools (loTools, Addbs (Addbs (tcFolder) + ccMyTools), .T.)
		This.AddFolderTools (loTools, tcFolder, .F.)
		
		* Save the path in the collection.
		
		loTools.Tag = tcFolder
		Return loTools
		
	ENDPROC

	PROCEDURE Init
		lparameters tcFolder
		local lcFolder
		
		tcFolder = _screen.cThorFolder
		This.cAppFolder = Addbs(JustPath(JustPath(tcFolder)))
		lcFolder = addbs(tcFolder)
		This.cThorFolder = lcFolder
		This.cTablesFolder = lcFolder + 'Tables\'
		This.cToolsFolder  = lcFolder + 'Tools\'
		
		This.OpenTables()
		
		*** JRN 2011-04-14 : 
		Set Deleted On
		
	ENDPROC

	PROCEDURE opentable
		Lparameters tcTableName, tcOrder
		
		Local lcFolder
		lcFolder = This.cTablesFolder
		
		Do Case
			Case Used(tcTableName)
		
			Case Pcount() = 1
				Use (lcFolder + tcTableName) Shared Again In 0
		
			Otherwise
				Use (lcFolder + tcTableName) Shared Again In 0 Order &tcOrder
		
		Endcase
		
		
	ENDPROC

	PROCEDURE opentables		&& Opens the Thor tables
		*==============================================================================
		* Method:			OpenTables
		* Purpose:			Opens the Thor tables
		* Author:			Doug Hennig
		* Last revision:	04/05/2011
		* Parameters:		none
		* Returns:			none
		* Environment in:	This.cTablesFolder contains the folder containing the
		*						tables, and that folder exists
		* Environment out:	the tables are opened if they aren't already
		*==============================================================================
		
		* Open the tables we need.
		
		If Used('VFPHotKeys')
			Return
		EndIf
		
		This.OpenTable('MenuDefinitions')
		This.OpenTable('HotKeyDefinitions')
		This.OpenTable('MenuTools')
		This.OpenTable('ToolHotKeyAssignments')
		This.OpenTable('StartupTools', 			'PRGName')
		This.OpenTable('ToolBarTools', 			'PRGName')
		This.OpenTable('Favorites', 			'PRGName')
		This.OpenTable('TableAliases')
		This.OpenTable('Thor')
		This.OpenTable('HotKeys')
		This.OpenTable('VFPHotKeys')
		
		*!* ******** JRN Removed 2023-03-16 ********
		*!* Local laStack[1], lcCursor, lnI
		
		*!* lcCursor = 'Stack' + Sys(2015)
		*!* Create Cursor (m.lcCursor) (Value C(100))
		*!* Astackinfo(laStack)
		*!* For lnI = 1 To Alen(m.laStack)
		*!* 	Insert Into (m.lcCursor) Values (Transform(m.laStack[m.lnI]))
		*!* Endfor
		
	ENDPROC

	PROCEDURE packtable
		*==============================================================================
		* Method:			PakcTables
		* Purpose:			Packs a single Thor table, if possible
		* Author:			Jim Nelson
		* Last revision:	04/14/2011
		* Parameters:		lcAlias -- alias of table to be packed
		* Returns:			none
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		Lparameters lcAlias
		
		Local lcDBF, lcOrder, lnSelect
		
		If not Used(lcAlias)
			Return
		EndIf
		
		lnSelect = Select()
		
		Select (lcAlias)
		lcDBF	= Dbf()
		lcOrder	= Order()
		
		Try
			Use (lcDBF) Exclusive
			Pack
		
			Use (lcDBF) Shared
			If Not Empty (lcOrder)
				Set Order To (lcOrder)
			Endif
		Catch
		
		Endtry 
		
		Select (lnSelect)
	ENDPROC

	PROCEDURE packtables
		*==============================================================================
		* Method:			PakcTables
		* Purpose:			Packs each of the Thor tables, if possible
		* Author:			Jim Nelson
		* Last revision:	04/14/2011
		* Parameters:		none
		* Returns:			none
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		With This
			.PackTable ('MenuDefinitions')
			.PackTable ('HotKeyDefinitions')
			.PackTable ('MenuTools')
			.PackTable ('ToolHotKeyAssignments')
		Endwith
	ENDPROC

	PROCEDURE removeitemfrommenu		&& Removes the specified item from the specified menu
		*==============================================================================
		* Method:			RemoveItemFromMenu
		* Purpose:			Removes the specified item from the specified menu
		* Author:			Doug Hennig
		* Last revision:	03/23/2011
		* Parameters:		tnID - the ID of the item to remove
		* Returns:			none
		* Environment in:	see This.OpenTables for requirements
		* Environment out:	the record is removed from MenuTools
		*==============================================================================
		
		lparameters tnID
		
		* Open the tables if necessary.
		
		This.OpenTables()
		
		* Ensure we have valid parameters.
		
		*** JRN 2011-04-13 : OOPS ... Or, not and
		if vartype(tnID) <> 'N' or ;
			not seek(tnID, 'MenuTools', 'ID')
			error 11
		endif vartype(tnID) <> 'N' ...
		delete in MenuTools
		
	ENDPROC

	PROCEDURE removemenu		&& Removes the specified menu
		*==============================================================================
		* Method:			RemoveMenu
		* Purpose:			Removes the specified menu
		* Author:			Doug Hennig
		* Last revision:	03/24/2011
		* Parameters:		tnMenuID         - the ID for the menu to remove (required)
		*					tlRemoveTopLevel - .T.  to remove only a top-level instance
		*						of the menu and leave any others
		*					tlRemovePopup    - .T.  to remove only a popup instance
		*						of the menu and leave any others
		*					tlRemoveSubMenu  - .T.  to remove only a submenu instance
		*						of the menu and leave any others
		* Returns:			none
		* Environment in:	see This.OpenTables for requirements
		* Environment out:	the MenuDefinitions record for the menu was updated if
		*						one of tlRemoveTopLevel or tlRemovePopup is .T.
		*					the MenuDefinitions record for the menu was removed if
		*						tlRemoveTopLevel, tlRemovePopup, and tlRemoveSubMenu
		*						are all .F. or the last instance of the menu is being
		*						removed. In that case, all MenuTools records for it are
		*						removed as well
		*==============================================================================
		
		lparameters tnMenuID, ;
			tlRemoveTopLevel, ;
			tlRemovePopup, ;
			tlRemoveSubMenu
		local lnSelect
		
		* Open the tables if necessary.
		
		This.OpenTables()
		
		* See where the menu is being used.
		
		= seek(tnMenuID, 'MenuDefinitions', 'ID')
		llTopLevel = MenuDefinitions.TopLevel
		llPopup    = MenuDefinitions.Popup
		llSubMenu  = seek(MenuDefinitions.ID, 'MenuTools', 'SubMenuID')
		do case
		
		* If we're removing it from the top level but it still exists elsewhere, turn
		* off the TopLevel flag.
		
			case tlRemoveTopLevel and (llPopup or llSubMenu)
				replace TopLevel with .F. in MenuDefinitions
		
		* If we're removing it as a popup but it still exists elsewhere, turn off the
		* Popup flag.
		
			case tlRemovePopup and (llTopLevel or llSubMenu)
				replace Popup with .F., HotKeyID with 0 in MenuDefinitions
		
		* If we're removing it as a submenu but it still exists elsewhere, delete the
		* MenuTools record that makes it a submenu. Renumber the tools for the menu the
		* submenu belonged to.
		
			case tlRemoveSubMenu and (llTopLevel or llPopup)
				lnMenuID = MenuTools.MenuID
				delete in MenuTools
				This.RenumberMenuItems(lnMenuID)
		
		* Delete the menu altogether. Delete the tools and separators in the menu. We
		* may also have to delete submenus if they aren't used for anything else.
		
			otherwise
				delete in MenuDefinitions
				delete from MenuTools where (MenuID = tnMenuID and SubMenuID = 0) or ;
					SubMenuID = tnMenuID
		
		* Now go through the submenus that belong to the menu and decide what to do
		* with them.
		
				lnSelect = select()
				select MenuTools
				scan for MenuID = tnMenuID
					lnSubMenuID = SubMenuID
					lnRecno     = recno()
					delete
		
		* See if another menu uses this submenu.
		
					llUsed = seek(lnSubMenuID, 'MenuTools', 'SubMenuID')
					go lnRecno
					do case
		
		* It is used by another menu, so do nothing.
		
						case llUsed
		
		* It isn't used by another menu so find the submenu in MenuDefinitions. If we
		* can't (which shouldn't happen), we'll just clean up MenuTools.
		
						case not seek(lnSubMenuID, 'MenuDefinitions', 'ID')
							delete for MenuID = lnSubMenuID
		
		* If it isn't used as either a top-level or popup menu, we'll delete the submenu.
		
						case not MenuDefinitions.TopLevel and not MenuDefinitions.Popup
							delete in MenuDefinitions
							delete for MenuID = lnSubMenuID
					endcase
				endscan for MenuID = tnMenuID
		
		* Renumber all menus and the items in them.
		
				This.RenumberMenus()
				select MenuDefinitions
				scan
					This.RenumberMenuItems(ID)
				endscan
				select (lnSelect)
		endcase
		
	ENDPROC

	PROCEDURE removetool
		Lparameters lcPRGName
		
		* Return full file name and path
		Local lcFileName, llFailed
		lcPRGName  = Forceext (lcPRGName, 'prg')
		lcFileName = Execscript (_Screen.cThorDispatcher, 'Full Path=' + lcPRGName)
		
		If Empty (lcFileName)
			Return .F.
		Endif
		
		Try
			Erase (Forceext (lcFileName, 'prg'))
			Erase (Forceext (lcFileName, 'fxp'))
			llFailed = .F.
		Catch
			llFailed = .T.
		EndTry 
		
		If llFailed
			Return .F.
		Endif
		
		* now, is there one left in Tools?
		lcFileName    = Execscript (_Screen.cThorDispatcher, 'Full Path=', lcPRGName)
		If Empty (lcFileName)
			This.OpenTables()
			Delete From ToolHotKeyAssignments Where Upper (PRGName) = Upper (lcPRGName)
			Delete From MenuTools Where Upper (PRGName) = Upper (lcPRGName)
		Endif
		
		
		
	ENDPROC

	PROCEDURE removetoolhotkey		&& Removes the hot key for the specified tool
		*==============================================================================
		* Method:			RemoveToolHotKey
		* Purpose:			Removes the hot key for the specified tool
		* Author:			Doug Hennig
		* Last revision:	03/25/2011
		* Parameters:		tcPRGName - the PRG name of the tool (required)
		* Returns:			none
		* Environment in:	none
		* Environment out:	all records in ToolHotKeyAssignments for the specified
		*						tool are deleted
		*==============================================================================
		
		lparameters tcPRGName, ;
			tnKeyCode, ;
			tnShiftCtrlAlt
		
		* Open the tables if necessary.
		
		This.OpenTables()
		
		* Ensure we have valid parameters.
		
		if vartype(tcPRGName) <> 'C' or empty(tcPRGName)
			error 11
		endif vartype(tcPRGName) <> 'C' or empty(tcPRGName)
		
		* Create a record in ToolHotKeyAssignments if necessary.
		
		delete from ToolHotKeyAssignments where upper(PRGName) = upper(tcPRGName)
		
	ENDPROC

	PROCEDURE renumbermenuitems		&& Renumbers the items for the specified menu so there are no gaps in the sequence
		*==============================================================================
		* Method:			RenumberMenuItems
		* Purpose:			Renumbers the items for the specified menu so there are no
		*						gaps in the sequence
		* Author:			Doug Hennig
		* Copyright:		(c) 2011 Stonefield Systems Group Inc.
		* Last revision:	03/24/2011
		* Parameters:		tnMenuID - the ID for the menu to renumber the items for
		* Returns:			none
		* Environment in:	none
		* Environment out:	the items in MenuTools for the specified menu have been
		*						renumbered to a complete sequence
		*==============================================================================
		
		lparameters tnMenuID
		local lnSelect, ;
			lcOrder, ;
			lnItem
		
		* Open the tables if necessary.
		
		This.OpenTables()
		
		* Ensure we have valid parameters.
		
		if vartype(tnMenuID) <> 'N'
			error 11
		endif vartype(tnMenuID) <> 'N'
		
		* Renumber the items.
		
		lnSelect = select()
		select MenuTools
		lcOrder = order()
		set order to SortOrder
		lnItem = 0
		scan for MenuID = tnMenuID
			lnItem = lnItem + 1
			replace SortOrder with lnItem
		endscan for MenuID = tnMenuID
		set order to (lcOrder)
		select (lnSelect)
		
	ENDPROC

	PROCEDURE renumbermenus		&& Renumbers all menus so there are no gaps in the sequence
		*==============================================================================
		* Method:			RenumberMenus
		* Purpose:			Renumbers all menus so there are no gaps in the sequence
		* Author:			Doug Hennig
		* Copyright:		(c) 2011 Stonefield Systems Group Inc.
		* Last revision:	03/24/2011
		* Parameters:		none
		* Returns:			none
		* Environment in:	none
		* Environment out:	the items in MenuDefinitions have been renumbered to a
		*						complete sequence
		*==============================================================================
		
		local lnSelect, ;
			lcOrder, ;
			lnItem
		
		* Open the tables if necessary.
		
		This.OpenTables()
		
		* Renumber the items.
		
		lnSelect = select()
		select MenuDefinitions
		lcOrder = order()
		set order to SortOrder
		lnItem = 0
		scan for SortOrder > 0
			lnItem = lnItem + 1
			replace SortOrder with lnItem
		endscan for SortOrder > 0
		set order to (lcOrder)
		select (lnSelect)
		
	ENDPROC

	PROCEDURE setmenuprompt
		*==============================================================================
		* Method:			SetMenuPrompt
		* Purpose:			Sets the prompt for a menu
		* Author:			Jim Nelson
		* Last revision:	08/24/2011 JRN
		* Parameters:		tnID     - ID for the menu       
		*                   tcPrompt - the new prompt
		* Returns:			the ID of the menu if found and 0 if not
		* Environment in:	see This.OpenTables for requirements
		* Environment out:	MenuDefinitions is positioned to the record with the name
		*						if found and EOF if not
		*==============================================================================
		
		Lparameters tnID, tcPrompt
		Local lnSelect
		
		* Open the tables if necessary.
		
		This.OpenTables()
		
		lnSelect = Select()
		Select MenuDefinitions
		Locate For Id = tnID
		If Found()
			Replace Prompt With tcPrompt
		Endif
		Select (lnSelect)
		Return
		
	ENDPROC

	PROCEDURE setoption
		*==============================================================================
		* Method:			SetOption
		* Purpose:			Sets the value of the specified Thor option
		* Author:			Jim Nelson
		* Last revision:	04/09/2011
		* Parameters:		tcKey - the key for the option
		*					tcTool - name of the tool this applies to (internally, may be left off)
		*					tuValue - the new value for the option
		*					tcDisplayValue - the display value for the option
		*						if different than Transform(tuValue)
		* Returns:			.T. if updated or NULL if it wasn't found
		* Environment in:	Thor.DBF is open
		* Environment out:	Thor.DBF is positioned to the record for the option or EOF
		*						if it wasn't found
		*==============================================================================
		
		Lparameters tcKey, tcTool, tuValue, tcDisplayValue
		Local lcType, lnSelect, luReturn
		
		* Open the tables if necessary.
		
		This.OpenTables()
		
		* Find the key in Thor and convert the value to the desired data type.
		
		lnSelect = Select()
		Select Thor
		Locate For Upper (Key) = Padr (Upper (tcKey), 30)  ;
			And Upper (Tool) = Padr (Upper (Evl (tcTool, 'Thor')), 60)
		lcType = Vartype (tuValue)
		
		Do Case
			Case Not Found()
				Insert Into Thor (Key, Tool) Values	(tcKey, tcTool)
				Return This.SetOption(tcKey, tcTool, tuValue, tcDisplayValue)
		
			Case IsNull(tuValue)
				Replace	Value	 With  '.Null.'														  ;
					  , Display	 With  '.Null.'														  ;
					  , Type	 With  'X'
				luReturn = .T.
		
			Case lcType = 'C'
				Replace	Value	 With  tuValue														  ;
					  , Display	 With  Iif ('C' = Vartype (tcDisplayValue), tcDisplayValue, tuValue)  ;
					  , Type	 With  'C'
				luReturn = .T.
		
			Case lcType = 'N'
				Replace	Value	 With  Transform (tuValue)													;
					  , Display	 With  Iif ('C' = Vartype (tcDisplayValue), tcDisplayValue, Transform (tuValue)) ;
					  , Type	 With  'N'
				luReturn = .T.
		
			Case lcType = 'D'
				Replace	Value	 With  Transform (tuValue - Date(1899, 12, 30))									;
					  , Display	 With  Iif ('C' = Vartype (tcDisplayValue), tcDisplayValue, Transform (tuValue)) ;
					  , Type	 With  'D'
				luReturn = .T.
		
			Case lcType = 'L'
				Replace	Value	 With  Iif (tuValue, 'Y', 'N')												;
					  , Display	 With  Iif ('C' = Vartype (tcDisplayValue), tcDisplayValue, Iif (tuValue, 'Yes', 'No')) ;
					  , Type	 With  'L'
				luReturn = .T.
			Otherwise
				luReturn = .F.
		Endcase
		Select (lnSelect)
		Return luReturn
		
	ENDPROC

ENDDEFINE
