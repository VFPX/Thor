Lparameters;
	tcCommandLine,;
	tcLaunchDir,;
	tlShow

Local;
	lnExitCode As Integer,;
	loAPI      As "API_AppRun" Of "..\..\BIN2TEXT\LIBRARY\BIN_2_TEXT.VCX"


IF m.tlShow THEN
	loAPI = Newobject('API_AppRun','','',m.tcCommandLine,m.tcLaunchDir,'NOR')
ELSE  &&m.tlShow THEN
	loAPI = Newobject('API_AppRun','','',m.tcCommandLine,m.tcLaunchDir,'HID')
ENDIF &&m.tlShow THEN
	
lnExitCode	= -1

If Vartype(m.loAPI)='O' And !Isnull(m.loAPI) Then
	If Empty(m.loAPI.icErrorMessage) Then
		If m.loAPI.LaunchAppAndWait() Then
*    tnExitCode = NVL(m.loAPI.CheckProcessExitCode(),-1)
			lnExitCode	= m.loAPI.CheckProcessExitCode()
			lnExitCode	= Nvl(m.lnExitCode,-1)
		Endif &&m.loAPI.LaunchAppAndWait()
	Endif &&EMPTY(m.loAPI.icErrorMessage)

	If !Empty(m.loAPI.icErrorMessage) Then
		Messagebox(m.loAPI.icErrorMessage,0,'API Run / ExpandZip')
	Endif &&!EMPTY(m.loAPI.icErrorMessage)
Endif &&VARTYPE(m.loAPI)='O' AND !ISNULL(m.loAPI)

loAPI = .Null.
If Pemstatus(_Screen,"xThorResult",5)
_Screen.xThorResult = m.lnExitCode=0
Endif &&PEMSTATUS(_Screen,"xThorResult",5)

Return m.lnExitCode=0

Define Class api_apprun As Custom 		&& Ed Raus API_AppRun, see UT download

	Protected inprocesshandle,inthreadhandle
	iccommandline = (Space(0))
	icErrorMessage = (Space(0))
	iclaunchdir = (Space(0))
	icwindowmode = (Space(0))
	inprocesshandle = .Null.
	inthreadhandle = .Null.
	Name = "api_apprun"

	Procedure CheckProcessExitCode
		Lparameter nProcessToCheck
		If Type('nProcessToCheck') # 'N'
			nProcessToCheck = This.inprocesshandle
		Endif
		Declare SHORT GetExitCodeProcess In Win32API As CheckExitCode ;
			integer hProcess, ;
			integer @lpdwExitCode
		Local nExitCode
		nExitCode = 0
		If ! Isnull(nProcessToCheck)
			If CheckExitCode(nProcessToCheck, @nExitCode) = 1
*	We retrieved an exit code (259 means still running, tho
				Return nExitCode
			Else
*	Process did not exist in process table - no exit status
				This.icErrorMessage = 'Process to check not in active Process Table'
				Return Null
			Endif
		Else
			This.icErrorMessage = 'NULL process handle passed to CheckProcessExitCode'
			Return .Null.
		Endif

	Endproc

	Procedure Destroy
		With This
			If Type('.inThreadHandle') = 'N' And Not Isnull(.inthreadhandle)
				.ReleaseHandle(.inthreadhandle)
				.inthreadhandle = Null
			Endif
			If Type('.inProcessHandle') = 'N' And Not Isnull(.inprocesshandle)
				.ReleaseHandle(.inprocesshandle)
				.inprocesshandle = Null
			Endif
		Endwith
		Clear Dlls CheckExitCode, KillProc, CrPr, GetCurrProc, WaitInpIdle, WaitOnAppExit, CloseHand
		DoDefault()

	Endproc

	Procedure extractdword
		Lparameter cStringToExtractFrom
		If Type('cStringToExtractFrom')='C' And Len(cStringToExtractFrom) >= 4
			Return (((Asc(Subst(cStringToExtractFrom,4,1))*256) + ;
				asc(Subst(cStringToExtractFrom,3,1)))*256 + ;
				asc(Subst(cStringToExtractFrom,2,1)))*256 + ;
				asc(Left(cStringToExtractFrom,1))
		Else
			This.icErrorMessage = 'Invalid DWORD string passed for conversion'
			Return Null
		Endif

	Endproc

	Procedure getprochandle
		Return This.inprocesshandle
	Endproc

	Procedure Init
*
*	API_AppRun - use the CreateProcess() API to launch, monitor, and kill an Executable
*
*	Properties:
*
*	inProcessHandle			(P)	ProcessHandle generated by CreateProcess()
*	inThreadHandle			(P) ThreadHandle for First Thread of inProcessHandle
*	icErrorMessage			R/O Error Message Detailed Description
*	icCommandLine			R/W Command Line to launch via CreateProcess()
*	icLaunchDir				R/W Directory to use as startup dir for CreateProcess()
*	icWindowMode			R/W Window Start Mode, one of (HID, NOR, MIN, MAX) or empty
*							defaults to empty, the default for the executable is used
*
*	Methods:
*
*	Init					(O) Command Line, (O) Start Dir, (O) Window Start Mode
*							If sent, the icCommandLine, icLaunchDir and icWindowMode properties are set
*	Destroy
*	LaunchApp				// Launches .icComandLine from .icLaunchDir in .icWindowMode
*							// NB - at least .icCommandLine must be set to not fail
*							RETURNS: BOOL, check icErrorMessage on .F.
*	LaunchAppAndWait		// Call LaunchApp() and wait on either user termination or process termination
*							RETURNS: BOOL, check icErrorMessage on .F.
*	CheckProcessExitCode	(O) Process handle to check, defaults to .inProcessHandle
*							// Get Process named by Process Handle's Exit Code (259 = still running)
*							RETURNS:  Integer, check on NULL, if NULL, check icErrorMessage
*	ExtractDWORD			(R) String to convert
*							//Converts a 4 byte or longer string to a DWORD integer
*							RETURNS:  Integer, check on NULL, if NULL arg was invalid
*	KillProc				(O) Process handle to Terminate, defaults to .inProcessHandle
*							// Kills specified process using TerminateProcess()
*							RETURNS:  BOOL, check icErrorMessage on .F.
*	GetProcHandle			//  Returns the Process Handle for the current Process
*							// NB - only useful for KillProc(), since Destroy will close the handle
*							RETURNS:  Integer, check for NULL, if NULL no process was started yet
*	ParsePROCESSINFOStruc	// Pulls the Process Handle and Thread Handle from the PROCESSINFO structure
*							// Only used internally
*	ReleaseHandle			(R)  Handle to Close
*							//  Invokes CloseHandle() to explicitly release process/thread handles
*							//  Only used internally, but can be externalized
*							RETURNS:  BOOL, check .icErrorMessage if false
*
		Lparameters tcCommandLine, tcLaunchDir, tcWindowMode
*	Set up the environment for the object
		Local aDirTest[1,5]
		With This
			.icErrorMessage = ''
			.iccommandline = ''
			.iclaunchdir = ''
			.icwindowmode = ''
			.inprocesshandle = Null
			.inthreadhandle = Null
* store parameters if passed
			If Type('tcCommandLine') = 'C'
				.iccommandline = Alltrim(tcCommandLine)
			Endif
			Do Case
				Case Type('tcLaunchDir') # 'C'
*	Not a character expression - ignore
				Case Adir(aDirTest, tcLaunchDir, 'D') # 1
*	Either directory doesn't exist, or there's a wildcard in the expression
					.icErrorMessage = 'Invalid directory for startup passed to Init method'
				Otherwise
*	Valid directory - save it
					.iclaunchdir = Alltrim(tcLaunchDir)
			Endcase
			Do Case
				Case Type('tcWindowMode') # 'C'
*	Not passed in or not valid type
				Case Inlist(Padr(Upper(Alltrim(tcWindowMode)),3),'NOR','MIN','MAX','HID')
*	Valid mode - set it
					.icwindowmode = Padr(Upper(Alltrim(tcWindowMode)),3)
				Otherwise
*	No a valid character string
					If ! Empty(.icErrorMessage)
						.icErrorMessage = .icErrorMessage + ' & '
					Endif
					.icErrorMessage = .icErrorMessage + Chr(10) + Chr(13) + 'Invalid WindowMode passed to Init Method'
			Endcase
		Endwith
		Return .T.

	Endproc

	Procedure KillProc
		Lparameter nProcessToKill
		If Type('nProcessToKill') # 'N'
			nProcessToKill = This.inprocesshandle
		Endif
		Declare SHORT TerminateProcess In WIN32API As KillProc ;
			integer hProcess, ;
			integer uExitCode
		Local nResult
		If ! Isnull(nProcessToKill)
			nResult = KillProc(nProcessToKill,0)
			This.icErrorMessage = Iif(nResult = 0, 'TerminateProcess() could not kill process handle requested','')
		Else
			This.icErrorMessage = 'NULL handle passed to KillProc()'
			nResult = 0
		Endif
		Return (nResult = 1)
	Endproc

	Procedure launchapp
		Local cCommandLine, uFromDir, cWindowMode
		With This
			.icErrorMessage = ''
			If Type('.icCommandLine') # 'C'
*	Command line must be a character string
				.icErrorMessage = 'icCommand line must be set, and a string value'
				Return .F.
			Else
				cCommandLine = Alltrim(.iccommandline)
			Endif
			If Type('.icLaunchDir') # 'C' Or Empty(.iclaunchdir)
*	If not a character string, pass a null pointer, defaulting to Current Working Dir
				uFromDir = 0
			Else
*	Otherwise, null pad the string
				uFromDir = .iclaunchdir + Chr(0)
			Endif
			If Type('.icWindowMode') # 'C'
*	If not passed, set to null string
				cWindowMode = ''
			Else
*	Translate the passed window mode to uppercase
				cWindowMode = Upper(.icwindowmode)
			Endif
*	This API call does the work.  The parameters are as follows:
*		lpszModuleName - ptr-> file name of module to execute.  Since we aren't launching .CPLs, do not use
*		lpszCommandLine - ptr-> command to execute, as passed in method
*		lpSecurityAttributesProcess - ptr-> SECURITY_ATTRIBUTES structure for Process.  Pass a null pointer
*		lpSecurityAttributesThread - ptr-> SECURITY_ATTRIBUTES structure for first thread.  Pass a null pointer
*		bInheritHandles - whether or not chlid inherits parent handles.  Since no SECURITY_ATTRIBUTES passed, default to FALSE
*		dwCreateFlags - Process Creation Mode flag set.  we use the default mode at normal priority, ie 0
*		lpvEnvironment	- ptr-> a set of environment strings as if a MULTI_SZ.  We don't set, so pass a null pointer
*		lpszStartupDir - ptr-> the starting directory.  If none provided to method, pass a null pointer
*		lpStartInfo - ptr-> a STARTUPINFO structure.  We use one structure member at times.
*		lpProcessInfo - ptr-> a PROCESS_INFORMATION structure, used to return PID/PHANDLE detail.  We use one member
*Declare Integer Wow64EnableWow64FsRedirection In kernel32 Integer nEnable
			Declare SHORT CreateProcess In WIN32API As CrPr ;
				string lpszModuleName, ;
				string @lpszCommandLine, ;
				string lpSecurityAttributesProcess, ;
				string lpSecurityAttributesThread, ;
				SHORT bInheritHandles, ;
				integer dwCreateFlags, ;
				string lpvEnvironment, ;
				string lpszStartupDir, ;
				string @lpStartInfo, ;
				string @lpProcessInfo

*Wow64EnableWow64FsRedirection(.f.)
			Local cProcessInfo, cStartUpInfo

*	Make default Structures for the CreateProcess call
*
*	ProcessInfo - 4 bytes, a Process handle, a Thread Handle, a (DWORD) ProcessId and a (DWORD) ThreadID
*					we save the Process handle and return it to caller in tnReturnProcessHandle

			cProcessInfo = Repl(Chr(0),16)

*	StartUpInfo is a 68 byte long complex structure;  we either have 68 bytes with a cb member (byte 1) 68
*	or with cb of 68, dwFlag low order byte (byte 45) of 1, and low order byte wShowWindow (byte 49) set to
*	the SW_ value appropriate for the Window Mode desired.

			Do Case
				Case cWindowMode = 'HID'
*	Hide - use STARTF_USESHOWFLAG and value of 0
					cStartUpInfo = Chr(68) + ;
						repl(Chr(0),43) + ;
						chr(1) + ;
						repl(Chr(0),23)
				Case cWindowMode = 'NOR'
*	Normal - use STARTF_USESHOWFLAG and value of 1
					cStartUpInfo = Chr(68) + ;
						repl(Chr(0),43) + ;
						chr(1) + ;
						repl(Chr(0),3) + ;
						chr(1) + ;
						repl(Chr(0),19)
				Case cWindowMode = 'MIN'
*	Minimize - use STARTF_USESHOWFLAG and value of 2
					cStartUpInfo = Chr(68) + ;
						repl(Chr(0),43) + ;
						chr(1) +  ;
						repl(Chr(0),3) + ;
						chr(2) + ;
						repl(Chr(0),19)
				Case cWindowMode = 'MAX'
*	Maximize - use STARTF_USESHOWFLAG and value of 3
					cStartUpInfo = Chr(68) + ;
						repl(Chr(0),43) + ;
						chr(1) +  ;
						repl(Chr(0),3) + ;
						chr(3) + ;
						repl(Chr(0),19)
				Otherwise
*	Use default of application
					cStartUpInfo = Chr(68) + Repl(Chr(0),67)
			Endcase
			Local lResult
			lResult = CrPr(	0, ;
				cCommandLine, ;
				0, 0, 0, 0, 0, ;
				uFromDir, ;
				@cStartUpInfo, ;
				@cProcessInfo)
*	Strip the handles from the PROCESS_INFORMATION structure and save in private properties
			If lResult = 1
				.ParseProcessInfoStruc(cProcessInfo)
				Return .T.
			Else
				.icErrorMessage = 'Process Specified by icCommandLine could not be started'
				Return .F.
			Endif
		Endwith
	Endproc

	Procedure LaunchAppAndWait
		#Define cnINFINITE 		0xFFFFFFFF
		#Define cnHalfASecond	500	&& milliseconds
		#Define cnTimedOut		258	&& 0x0102
*	We need some API calls, declare here
*	GetCurrentProcess returns the pseudohandle of the current process (ie VFP instance)
		Declare Integer GetCurrentProcess In WIN32API As GetCurrProc
*	WaitForIdleInput waits until the application is instantiated and at it's event loop
		Declare Integer WaitForInputIdle In WIN32API As WaitInpIdle ;
			integer nProcessHandle, ;
			integer nWaitForDuration
*	WaitForSingleObject waits until the handle in parm 1 is signalled or the timeout period expires
		Declare Integer WaitForSingleObject In WIN32API As WaitOnAppExit ;
			integer hProcessHandle, ;
			integer dwTimeOut
*	Save the Process handle if any and the result of LaunchApp
*	Fire the app and save the process handle
		Local uResult
		uResult = 0
		With This
			.icErrorMessage = ''
			If .launchapp()
				uResult = 1
*	It's been launched;  wait until we're idling along
				=WaitInpIdle(GetCurrProc(),cnINFINITE)
*	As long as the other process exists, wait for it
				Do While WaitOnAppExit(.inprocesshandle, cnHalfASecond) = cnTimedOut
*	Give us an out in case the other app hangs - let
					If Inkey() = 27
*	Still running but we aren't waiting - return a -1 as a warning
						.icErrorMessage = 'Process started but user did not wait on termination'
						uResult = 0
						Exit
					Endif
				Enddo
			Else
*	Return 0 to indicate failure
				uResult = 0
			Endif
		Endwith
		Return (uResult = 1)

	Endproc

	Procedure ParseProcessInfoStruc
		Lparameter cProcessInfoStructure
		With This
			.inprocesshandle = .extractdword(cProcessInfoStructure)
			.inthreadhandle = .extractdword(Subst(cProcessInfoStructure,5))
		Endwith


	Endproc

	Protected Procedure ReleaseHandle
		Lparameter nHandleToRelease
		Local nResult
*	Use CloseHandle(), returns a BOOL;  0 = False
		Declare SHORT CloseHandle In Win32API As CloseHand Integer nHandleToClose
		If Type('nHandleToRelease') = 'N' And ! Isnull(nHandleToRelease)
			nResult = CloseHand(nHandleToRelease)
			This.icErrorMessage = Iif(nResult = 0, 'TerminateProcess() failed to close handle','')
		Else
			This.icErrorMessage = 'Invalid handle passed to ReleaseHandle() invocation'
			nResult = 0
		Endif
		Return (nResult = 1)
	Endproc

Enddefine
